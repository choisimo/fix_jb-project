# 서비스 구현 완료도 및 기능 시연 PRD (Prototype Level)

## 1. 개요

본 문서는 시스템의 주요 서비스(데이터베이스 연동 및 외부 AI 모델 연동)의 구현 완료도를 분석하고, 그 결과를 보고서 형태로 생성하는 서비스의 상세 요구사항을 정의합니다. 이 PRD는 프로토타입 이상의 작동을 목표로 하며, 모든 기능이 시연 가능할 정도로 디테일하게 작성되었습니다.

## 2. 주요 기능 요구사항 (Key Feature Requirements)

### 2.1. 데이터베이스 연동 분석

**목표**: 시스템 내의 데이터베이스 스키마 정의 및 JPA(Java Persistence API) 구현 상태를 정확히 파악하고 보고합니다.

*   **2.1.1. RDB 스키마 확인**
    *   **요구사항**: 시스템은 `documents/database-structure.md` 파일 또는 `database/schema.sql`, `database/init.sql`과 같은 `.sql` 확장자를 가진 파일을 자동으로 탐지하여 데이터베이스 스키마 정의를 인지해야 합니다.
    *   **세부 구현**:
        *   지정된 경로(`documents/`, `database/`)에서 `database-structure.md` 또는 `.sql` 파일을 검색합니다.
        *   탐지된 파일의 내용을 파싱하여 테이블, 컬럼, 관계 등의 스키마 정보를 추출합니다. (SQL 파일의 경우 `CREATE TABLE`, `ALTER TABLE` 구문 분석)
        *   스키마 파일이 존재하지 않거나 파싱에 실패할 경우, 해당 상태를 보고서에 명시합니다.
    *   **검증**: 탐지된 스키마 파일 경로 및 파싱된 스키마 요약 정보가 보고서에 정확히 반영되는지 확인합니다.

*   **2.1.2. JPA 구현 검증 (Spring Boot 기준)**
    *   **요구사항**: Spring Boot 프로젝트 내에서 JPA 엔티티 및 리포지토리, 서비스 계층의 데이터 접근 로직 구현 상태를 검증합니다.
    *   **세부 구현**:
        *   **엔티티 클래스 존재 여부**: `spring-backend/src/main/java/**/*.java` 경로에서 `@Entity` 어노테이션이 사용된 클래스 파일을 검색합니다.
        *   **JpaRepository 상속 리포지토리**: `spring-backend/src/main/java/**/*.java` 경로에서 `JpaRepository` 인터페이스를 상속받는 인터페이스 파일을 검색합니다.
        *   **서비스 계층 메서드 호출 검증**: `@Service` 어노테이션이 사용된 서비스 클래스 내에서 탐지된 `JpaRepository` 인터페이스의 인스턴스를 주입받아 `save()`, `findById()`, `findAll()`, `delete()` 등 주요 CRUD 메서드가 실제로 호출되는지 정적 코드 분석을 통해 검증합니다.
        *   **연결성 검증**: 엔티티, 리포지토리, 서비스 간의 논리적 연결성(예: 특정 엔티티에 대한 리포지토리 및 서비스 메서드 존재 여부)을 확인합니다.
    *   **검증**: 탐지된 엔티티/리포지토리/서비스 클래스 파일 경로, 주요 CRUD 메서드 호출 여부 및 관련 코드 스니펫이 보고서에 정확히 명시되는지 확인합니다.

*   **2.1.3. 설정 파일 분석**
    *   **요구사항**: `spring-backend/src/main/resources/application.properties` 또는 `application.yml` 파일에서 데이터베이스 연결 정보(URL, username, password, driver-class-name 등)가 정의되어 있는지 확인합니다.
    *   **세부 구현**:
        *   지정된 경로에서 `application.properties` 또는 `application.yml` 파일을 검색합니다.
        *   파일 내용을 파싱하여 `spring.datasource.url`, `spring.datasource.username` 등의 키-값 쌍을 추출합니다.
        *   필수 연결 정보가 누락되었을 경우 보고서에 명시합니다.
    *   **검증**: 탐지된 설정 파일 경로 및 추출된 데이터베이스 연결 정보가 보고서에 정확히 반영되는지 확인합니다.

### 2.2. 외부 AI 모델 연동 분석

**목표**: 시스템 내의 외부 AI 서비스(예: Roboflow) 연동을 위한 설정 및 실제 API 호출 로직 구현 상태를 파악하고 보고합니다.

*   **2.2.1. 설정 정보 식별**
    *   **요구사항**: 코드 내에서 외부 AI 서비스(예: Roboflow)의 API Key, URL, 모델 정보 등이 정의된 설정 블록(예: Python 코드의 `WORKFLOW_CONFIG` 딕셔너리, 환경 변수 로딩 코드)을 식별합니다.
    *   **세부 구현**:
        *   `analyze_image.py`, `roboflow_test.py`, `config_manager.py` 등 AI 관련 Python 파일에서 `API_KEY`, `ROBOFLOW_URL`, `WORKFLOW_CONFIG`와 같은 변수명 또는 딕셔너리 구조를 검색합니다.
        *   환경 변수(`os.environ.get()`)를 통해 설정이 로드되는 패턴도 탐지합니다.
    *   **검증**: 탐지된 설정 변수명, 값(부분 마스킹 처리), 및 관련 파일 경로가 보고서에 정확히 명시되는지 확인합니다.

*   **2.2.2. API 호출 코드 검증**
    *   **요구사항**: 식별된 설정 정보를 바탕으로 실제 HTTP API 호출(예: `requests.post`, `urllib.request.urlopen`)이 일어나는지 확인합니다.
    *   **세부 구현**:
        *   AI 관련 Python 파일 내에서 `requests.post()`, `requests.get()`, `urllib.request.urlopen()` 등 HTTP 요청을 수행하는 함수 호출을 검색합니다.
        *   이러한 호출이 이전에 식별된 AI 서비스 URL 또는 API Key를 사용하는지 컨텍스트 분석을 통해 확인합니다.
    *   **검증**: 탐지된 API 호출 메서드, 사용된 URL/파라미터(부분 마스킹 처리), 및 관련 코드 스니펫이 보고서에 정확히 명시되는지 확인합니다.

*   **2.2.3. 동적 호출 구조 분석 (Kafka 연동 예시)**
    *   **요구사항**: 메시지 큐(예: Kafka) 등에서 받은 데이터(예: `category` 필드)에 따라 동적으로 다른 AI API를 호출하는 로직이 구현되었는지 분석합니다.
    *   **세부 구현**:
        *   Kafka 컨슈머 또는 메시지 처리 로직이 구현된 파일(예: `tasks_cleaner.py`, `integration_test.py` 또는 Spring Boot의 Kafka Listener)을 검색합니다.
        *   메시지 페이로드에서 특정 필드(예: `category`, `type`)를 읽어와 조건문(`if/elif/else`, `switch`)을 통해 다른 AI 모델 또는 엔드포인트를 호출하는 패턴을 분석합니다.
    *   **검증**: 동적 호출 로직이 탐지된 파일 경로, 조건 분기 예시, 및 관련 코드 스니펫이 보고서에 정확히 명시되는지 확인합니다.

### 2.3. 보고서 생성

**목표**: 분석 결과를 명확하고 가독성 높은 Markdown 형식으로 요약하고, 상세 근거 및 향후 조치를 제안합니다.

*   **2.3.1. 결과 요약**
    *   **요구사항**: 분석 결과를 바탕으로 "DB 연동: 구현 완료", "AI 모델 호출: 미구현" 과 같이 각 기능의 구현 상태를 명확히 요약해야 합니다.
    *   **세부 구현**:
        *   각 주요 기능(DB 연동, AI 모델 연동)에 대해 "구현 완료", "부분 구현", "설계만 된 상태", "미구현" 중 하나의 상태를 할당합니다.
        *   상태는 각 세부 요구사항(2.1.1 ~ 2.2.3)의 충족 여부에 따라 결정됩니다.
    *   **검증**: 보고서 상단에 각 기능의 요약 상태가 명확하게 표시되는지 확인합니다.

*   **2.3.2. 상세 근거 제시**
    *   **요구사항**: 각 결론에 대한 근거가 되는 코드 위치나 파일명, 관련 코드 스니펫을 제시해야 합니다. (예: "UserService.java에서 `userRepository.save()` 호출 확인")
    *   **세부 구현**:
        *   각 세부 요구사항 분석 시 탐지된 파일 경로, 라인 번호, 그리고 해당 로직의 핵심 코드 스니펫(최대 5줄)을 포함합니다.
        *   코드 스니펫은 Markdown의 코드 블록(` ``` `)으로 포맷팅합니다.
    *   **검증**: 모든 요약된 상태에 대해 충분한 상세 근거가 제공되는지 확인합니다.

*   **2.3.3. 향후 조치 제안**
    *   **요구사항**: 미구현되거나 불완전한 부분에 대해 필요한 다음 작업(예: "Entity 클래스 생성 필요", "Roboflow API Key 설정 필요")을 제안합니다.
    *   **세부 구현**:
        *   "부분 구현" 또는 "미구현" 상태인 기능에 대해 구체적이고 실행 가능한 다음 단계를 제안합니다.
        *   예시: "누락된 `application.yml` 파일 생성 및 DB 연결 정보 추가", "Roboflow API 호출을 위한 `requests` 라이브러리 임포트 및 `post` 메서드 구현".
    *   **검증**: 모든 미흡한 부분에 대해 명확한 향후 조치 제안이 포함되는지 확인합니다.

*   **2.3.4. 포맷**
    *   **요구사항**: 최종 보고서는 가독성이 좋은 Markdown 형식으로 생성되어야 합니다.
    *   **세부 구현**:
        *   제목, 소제목, 목록, 코드 블록 등을 활용하여 구조화된 Markdown 문서를 생성합니다.
        *   핵심 정보는 볼드체 등으로 강조하여 가독성을 높입니다.
    *   **검증**: 생성된 보고서가 Markdown 뷰어에서 올바르게 렌더링되고 가독성이 높은지 확인합니다.

## 3. 구현 완료의 정의 (Definition of Done)

본 서비스의 "구현 완료"는 다음 기준을 충족해야 합니다.

*   **설계만 된 상태**: 관련 문서(스키마 정의 등)는 있으나, 실제 기능 코드는 없는 경우. (예: `database-structure.md`는 있으나 `@Entity` 클래스가 없는 경우)
*   **부분 구현**: 엔티티나 설정 등 일부 요소는 구현되었으나, 실제 데이터를 처리하는 서비스 로직이나 API 호출부가 없는 경우. (예: `@Entity` 클래스와 `JpaRepository`는 있으나 서비스 계층에서 해당 리포지토리를 사용하는 코드가 없는 경우)
*   **구현 완료**: 설계된 기능과 관련된 모든 코드(모델, 리포지토리, 서비스, API 호출 등)가 유기적으로 연결되어 정상 동작할 것으로 예상되는 상태. 모든 분석 로직이 구현되어 정확한 보고서를 생성할 수 있는 상태.

## 4. 사용자 스토리 (User Stories)

*   **AS A** 개발자, **I WANT TO** 현재 프로젝트의 DB 연동 및 AI 모델 연동 상태를 한눈에 파악할 수 있는 보고서를 **SO THAT** 다음 개발 단계를 효율적으로 계획할 수 있다.
*   **AS A** QA 엔지니어, **I WANT TO** 특정 기능의 구현 완료도를 검증하기 위한 상세 근거와 코드 위치를 **SO THAT** 테스트 계획을 수립하고 버그를 추적하는 데 활용할 수 있다.
*   **AS A** 프로젝트 관리자, **I WANT TO** 각 서비스의 구현 진행 상황과 미흡한 부분을 명확히 파악할 수 있는 요약 보고서를 **SO THAT** 프로젝트의 전반적인 상태를 이해하고 리소스 배분을 결정할 수 있다.

## 5. 기술 설계 고려사항 (Technical Design Considerations)

*   **5.1. 언어 및 프레임워크**: Python (분석 및 보고서 생성 로직), Spring Boot (분석 대상 Java 프로젝트).
*   **5.2. 코드 분석 방식**: 정적 코드 분석 (AST 파싱, Regex 매칭)을 활용하여 소스 코드의 구조와 호출 관계를 파악합니다.
*   **5.3. 파일 시스템 접근**: 지정된 경로의 파일을 읽고 내용을 파싱하는 안정적인 파일 시스템 접근 로직을 구현합니다.
*   **5.4. 에러 핸들링**: 파일 미발견, 파싱 에러, 예상치 못한 코드 구조 등에 대한 견고한 에러 핸들링 및 보고서 반영.
*   **5.5. 성능**: 대규모 코드베이스에서도 합리적인 시간 내에 분석을 완료할 수 있도록 효율적인 파일 검색 및 파싱 로직을 고려합니다.

## 6. 테스트 및 검증 (Testing and Verification)

*   **6.1. 단위 테스트**:
    *   각 분석 모듈(스키마 파서, JPA 검증 로직, AI 설정 파서 등)에 대한 단위 테스트를 작성합니다.
    *   다양한 시나리오(파일 없음, 잘못된 포맷, 부분 구현 코드 등)에 대한 테스트 케이스를 포함합니다.
*   **6.2. 통합 테스트**:
    *   실제 프로젝트 구조와 유사한 더미 프로젝트를 생성하여 엔드-투-엔드 분석 및 보고서 생성 과정을 테스트합니다.
    *   DB 연동 및 AI 연동이 각각 "구현 완료", "부분 구현", "미구현" 상태인 더미 프로젝트를 사용하여 정확한 보고서가 생성되는지 확인합니다.
*   **6.3. 수동 검증**:
    *   생성된 Markdown 보고서를 사람이 직접 검토하여 가독성, 정확성, 상세 근거의 유효성, 향후 조치 제안의 실용성을 확인합니다.

## 7. 향후 개선 사항 (Future Enhancements)

*   **7.1. CI/CD 연동**: 분석 서비스를 CI/CD 파이프라인에 통합하여 코드 변경 시 자동으로 구현 완료도 보고서를 생성.
*   **7.2. 대시보드**: 분석 결과를 시각화하는 웹 대시보드 구현.
*   **7.3. 추가 서비스 분석**: 메시지 큐(Kafka), 캐싱(Redis), 인증/인가(Spring Security) 등 다른 핵심 서비스에 대한 구현 완료도 분석 기능 추가.
*   **7.4. 설정 유연성**: 분석 대상 경로, 파일명, 검색 패턴 등을 외부 설정 파일로 관리하여 유연성 증대.
*   **7.5. 심층 코드 분석**: 더 복잡한 코드 패턴(예: 런타임 시 동적으로 로드되는 클래스, 리플렉션 사용)에 대한 분석 기능 강화.