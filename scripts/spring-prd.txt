# PRD: Spring Boot 백엔드 아키텍처 개선

## 1. 문서 정보

- **문서 버전**: v1.0
- **작성일**: 2025년 6월 29일
- **대상 모듈**: Spring Boot Backend (`spring-backend`)
- **주요 변경 사항**: DTO 도입, 계층 간 역할 분리, QueryDSL을 이용한 Repository 개선

---

## 2. 개요

본 문서는 '전북 현장 보고 및 관리 플랫폼'의 Spring Boot 백엔드 시스템의 **유지보수성, 안정성, 확장성**을 향상시키기 위한 아키텍처 개선 요구사항을 정의합니다.

### 2.1. 변경 목표

-   **계층 간 역할 분리**: Controller, Service, Repository 각 계층의 역할을 명확히 분리하여 코드의 결합도를 낮추고 응집도를 높입니다.
-   **데이터 불변성 확보**: Controller 계층에서는 불변(Immutable) 객체인 DTO(Data Transfer Object)를 사용하여 데이터를 전달함으로써, 의도치 않은 데이터 변경을 원천적으로 방지하고 시스템의 안정성을 높입니다.
-   **쿼리 복잡성 감소**: JPA와 QueryDSL을 통합하여, 복잡한 동적 쿼리를 타입-세이프(Type-safe)하게 작성하고, 쿼리의 가독성과 유지보수성을 향상시킵니다.

### 2.2. 기대 효과

-   **유지보수성 향상**: 각 계층의 책임이 명확해져 코드 수정 및 기능 추가 시 다른 계층에 미치는 영향을 최소화할 수 있습니다.
-   **안정성 증대**: Controller에서 Domain 객체를 직접 사용하지 않고 불변 DTO를 사용함으로써, 데이터의 일관성을 유지하고 예기치 않은 버그 발생 가능성을 줄입니다.
-   **테스트 용이성**: 계층별 역할 분리로 인해 단위 테스트(Unit Test) 작성이 용이해집니다.
-   **개발 생산성 향상**: QueryDSL을 통해 복잡한 쿼리를 자바 코드로 작성할 수 있어, 컴파일 시점에 오류를 발견하고 자동완성 기능을 활용할 수 있습니다.

---

## 3. 아키텍처 요구사항

### 3.1. 계층별 역할 및 책임 정의

```mermaid
graph TD
    A[Client] --> B[Controller Layer]
    B --> C[Service Layer]
    C --> D[Repository Layer]
    D --> E[Database]

    subgraph "Presentation Layer"
        B("**Controller**<br/>- HTTP 요청/응답 처리<br/>- 입력값 검증 (Validation)<br/>- DTO와 Domain 객체 변환 요청")
    end

    subgraph "Business Logic Layer"
        C("**Service**<br/>- 핵심 비즈니스 로직 수행<br/>- 트랜잭션(Transaction) 관리<br/>- Domain 객체 처리")
    end

    subgraph "Data Access Layer"
        D("**Repository**<br/>- 데이터베이스 접근<br/>- CRUD 및 복잡한 쿼리 실행<br/>- QueryDSL 구현체 포함")
    end

    subgraph "Persistence Layer"
        E[(PostgreSQL)]
    end
```

-   **Controller Layer**: 오직 HTTP 요청을 받고 응답하는 역할만 수행합니다. 비즈니스 로직을 포함해서는 안 되며, Service 계층으로 DTO를 전달하고, Service 계층으로부터 받은 결과를 DTO로 변환하여 클라이언트에게 반환합니다.
-   **Service Layer**: 실제 비즈니스 로직을 처리합니다. `@Transactional` 어노테이션을 통해 트랜잭션을 관리하며, Repository를 통해 데이터베이스와 상호작용합니다. Domain 객체를 직접 다룹니다.
-   **Repository Layer**: 데이터베이스에 접근하는 역할만 수행합니다. `JpaRepository`를 상속하고, 복잡한 쿼리를 위해 QueryDSL을 구현합니다.

### 3.2. DTO(Data Transfer Object) 도입

-   **DTO 사용 원칙**: Controller의 모든 요청(Request)과 응답(Response)은 반드시 DTO를 통해 이루어져야 합니다. **Controller에서 Domain 객체(Entity)를 직접 참조하거나 반환하는 것을 금지합니다.**
-   **불변성**: 모든 DTO는 Java의 `record` 타입을 사용하여 불변(Immutable) 객체로 정의하는 것을 원칙으로 합니다. 이는 데이터의 일관성을 보장하고 스레드 안전성을 높입니다.
-   **입력값 검증**: 요청 DTO에는 `jakarta.validation.constraints` (e.g., `@NotBlank`, `@Size`, `@Email`) 어노테이션을 사용하여 입력값 검증 로직을 추가해야 합니다.

    ```java
    // 예시: 보고서 생성 요청 DTO
    public record ReportCreateRequest(
        @NotBlank String title,
        @Size(max = 4000) String content,
        @NotNull Long categoryId
    ) {}
    ```

### 3.3. QueryDSL 도입 및 Repository 개선

-   **Repository 인터페이스 분리**: 기본 CRUD를 위한 `JpaRepository` 인터페이스와, 복잡한 동적 쿼리를 위한 커스텀 인터페이스(예: `ReportRepositoryCustom`)로 분리합니다.
-   **QueryDSL 구현**: 커스텀 인터페이스의 구현체(예: `ReportRepositoryCustomImpl`)에서 `JPAQueryFactory`를 사용하여 QueryDSL로 동적 쿼리를 작성합니다.
-   **적용 대상**: 보고서 목록 조회 시 사용되는 다중 조건 필터링, 검색, 정렬 기능에 QueryDSL을 우선적으로 적용합니다.

    ```java
    // 1. 커스텀 인터페이스
    public interface ReportRepositoryCustom {
        Page<ReportSummaryDto> searchReports(ReportSearchCondition condition, Pageable pageable);
    }

    // 2. 구현체
    @Repository
    public class ReportRepositoryCustomImpl implements ReportRepositoryCustom {
        private final JPAQueryFactory queryFactory;

        // ... 생성자

        @Override
        public Page<ReportSummaryDto> searchReports(ReportSearchCondition condition, Pageable pageable) {
            QReport report = QReport.report;
            // QueryDSL을 사용한 동적 쿼리 작성
            List<ReportSummaryDto> content = queryFactory
                .select(new QReportSummaryDto(...))
                .from(report)
                .where(
                    titleContains(condition.getKeyword()),
                    statusIn(condition.getStatuses())
                )
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .orderBy(...)
                .fetch();
            // ... 카운트 쿼리 및 Page 객체 반환
        }

        private BooleanExpression titleContains(String keyword) { ... }
        private BooleanExpression statusIn(List<ReportStatus> statuses) { ... }
    }

    // 3. 메인 Repository 인터페이스
    public interface ReportRepository extends JpaRepository<Report, Long>, ReportRepositoryCustom {}
    ```

---

## 4. 구현 계획 및 리팩토링 가이드

1.  **DTO 클래스 생성**:
    -   기존 Controller에서 사용되던 Domain 객체를 분석하여, 각 API 엔드포인트에 맞는 요청/응답 DTO(`record` 타입)를 `com.jeonbuk.report.dto` 패키지 내에 생성합니다.

2.  **Controller 리팩토링**:
    -   모든 Controller 메소드의 파라미터와 반환 타입을 새로 생성한 DTO로 변경합니다.
    -   `@Valid` 어노테이션을 추가하여 요청 DTO에 대한 유효성 검사를 활성화합니다.

3.  **Service 리팩토링**:
    -   Controller로부터 DTO를 받아, 이를 Domain 객체로 변환하여 비즈니스 로직을 처리하도록 수정합니다.
    -   결과를 반환할 때는 Domain 객체를 DTO로 변환하여 Controller에 전달합니다. (ModelMapper, MapStruct 같은 라이브러리 사용을 고려할 수 있으나, 초기에는 정적 팩토리 메소드나 빌더 패턴으로 충분합니다.)

4.  **Repository 및 QueryDSL 구현**:
    -   `build.gradle`에 QueryDSL 관련 의존성을 추가하고, `compileQuerydsl` Gradle 태스크를 설정하여 Q-Type 클래스를 자동 생성합니다.
    -   복잡한 조회 로직이 필요한 Repository에 대해 커스텀 인터페이스와 QueryDSL 구현체를 추가합니다.

---

## 5. 테스트 계획

-   **Controller 테스트**: Mockito를 사용하여 Service 계층을 Mocking하고, DTO 유효성 검사 및 API 응답 형식이 올바른지 테스트합니다.
-   **Service 테스트**: 실제 비즈니스 로직이 정확하게 동작하는지, 트랜잭션이 올바르게 적용되는지 테스트합니다.
-   **Repository 테스트**: `@DataJpaTest`를 사용하여 QueryDSL로 작성된 쿼리가 예상대로 동작하는지 테스트합니다.

---

## 6. 성공 지표

-   Controller 계층의 코드에서 Domain 객체에 대한 참조가 모두 제거됨.
-   모든 요청/응답 데이터가 불변 DTO(`record`)를 통해 전달됨.
-   보고서 검색 기능이 QueryDSL을 통해 구현되고, 동적 쿼리가 정상적으로 동작함.
-   리팩토링 이후 모든 단위 테스트 및 통합 테스트가 성공적으로 통과함.
