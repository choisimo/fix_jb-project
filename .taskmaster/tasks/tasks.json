
{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Infrastructure and Core Services",
        "description": "Configure Docker Compose for core services: PostgreSQL, Redis, Kafka, Zookeeper. Set up Spring Boot project with necessary dependencies.",
        "details": "Write a `docker-compose.yml` file to define and link services: `postgres` (database), `redis` (cache/session), `zookeeper` (Kafka dependency), `kafka` (message queue). Initialize a Spring Boot project with dependencies for Web, JPA, Security, Kafka, Redis, etc. using Maven or Gradle.",
        "testStrategy": "Verify all services start correctly using `docker-compose up`. Check service logs for errors. Ensure Spring Boot application connects to DB, Redis, and Kafka.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "Docker Compose configured with Kafka, Zookeeper, PostgreSQL. Spring Boot project setup is complete with all necessary dependencies in pom.xml."
      },
      {
        "id": 2,
        "title": "Design and Implement Database Schema using JPA",
        "description": "Design and implement the database schema using JPA entities for users, reports, comments, and related data.",
        "details": "Create JPA entity classes: `User`, `Report`, `ReportFile`, `Comment`, `Category`, `Status`. Define relationships (@OneToMany, @ManyToOne, etc.) and constraints. Use `@Entity` annotations to map classes to database tables. Configure `application.properties` for Hibernate to generate or validate the schema.",
        "testStrategy": "Run the Spring Boot application and verify that all tables and columns are created in the PostgreSQL database as per the entity definitions. Insert sample data to check constraints and relationships.",
        "priority": "high",
        "dependencies": [1],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "JPA entities for User, Report, and related tables are defined. The schema is automatically generated by Hibernate."
      },
      {
        "id": 3,
        "title": "Implement User Authentication and Authorization",
        "description": "Set up Spring Security for user registration, login (email/password), and OAuth2 login (Google, Kakao). Implement role-based access control.",
        "details": "Configure Spring Security filter chain. Implement `UserDetailsService` to load user data. Use BCryptPasswordEncoder for passwords. Implement JWT token generation/verification for session management. Configure OAuth2 client properties for Google and Kakao. Implement controllers for `/api/auth/register`, `/api/auth/login`. Use method-level security (`@PreAuthorize`) for role-based access (`USER`, `MANAGER`).",
        "testStrategy": "Test user registration with valid/invalid data. Test email/password login and verify JWT token generation. Test OAuth2 login flow. Verify that endpoints restricted by role are only accessible by users with the correct role.",
        "priority": "high",
        "dependencies": [1, 2],
        "status": "in_progress",
        "notes": "Basic Spring Security configuration is in place. JWT and OAuth2 implementation is in progress."
      },
      {
        "id": 4,
        "title": "Implement Report Creation API",
        "description": "Implement the API endpoint for creating a new report, including handling report data and file uploads.",
        "details": "Create a POST endpoint `/api/reports` in a Spring Boot Controller. This endpoint should accept a multipart request containing report data (title, description, location) and files (images/videos). Authenticate the user making the request. Store the report data in the `reports` table and file metadata in the `report_files` table. Store uploaded files on a file system or cloud storage.",
        "testStrategy": "Send POST requests to `/api/reports` with valid report data and files. Verify that new entries are created in the `reports` and `report_files` tables. Check response status codes and data.",
        "priority": "high",
        "dependencies": [1, 2, 3],
        "status": "pending"
      },
      {
        "id": 5,
        "title": "Integrate Kafka Producer for Image Analysis Requests",
        "description": "Integrate Kafka producer in the report creation service to send image analysis requests to the `image-analysis-request` topic.",
        "details": "After a report with images is saved, use `KafkaTemplate` to send a message to the `image-analysis-request` topic. The message should contain the report ID and image file paths/URLs for the AI worker to process.",
        "testStrategy": "Create a report with images. Monitor the `image-analysis-request` Kafka topic to verify that messages with correct report and image information are produced.",
        "priority": "high",
        "dependencies": [4],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "ImageAnalysisService uses KafkaTemplate to send messages to Kafka."
      },
      {
        "id": 6,
        "title": "Develop AI Worker for Roboflow/OpenRouter Analysis",
        "description": "Develop the AI Worker service to consume messages from Kafka, call external AI APIs (Roboflow, OpenRouter) for analysis, and produce results to a results topic.",
        "details": "Create a Kafka consumer using `@KafkaListener` to listen to the `image-analysis-request` topic. For each message, use `WebClient` or `RestTemplate` to call the Roboflow and/or OpenRouter APIs. Parse the API responses to determine report category, priority, etc. Produce a new message with the analysis results to the `image-analysis-result` topic.",
        "testStrategy": "Run the application. Create reports with images via the API. Verify the worker consumes messages, calls external APIs, and produces messages to the `image-analysis-result` topic.",
        "priority": "high",
        "dependencies": [1, 5],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "AiRoutingService and ImageAnalysisService contain logic to call Roboflow and OpenRouter APIs."
      },
      {
        "id": 7,
        "title": "Integrate Kafka Consumer for Analysis Results",
        "description": "Integrate a Kafka consumer to process messages from the `image-analysis-result` topic and update the corresponding report in the database.",
        "details": "Create a `@KafkaListener` to consume messages from the `image-analysis-result` topic. When a message is received, extract the report ID and analysis results. Update the corresponding report entity in the PostgreSQL database with the AI-determined category and priority.",
        "testStrategy": "Ensure the AI worker is producing results. Verify the consumer receives messages and updates the reports in the database correctly.",
        "priority": "high",
        "dependencies": [6],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "A Kafka consumer is implemented to update reports with AI analysis results."
      },
      {
        "id": 8,
        "title": "Implement Real-time Notifications via WebSocket",
        "description": "Implement WebSocket communication to push real-time updates (AI analysis results, status changes) to clients.",
        "details": "Configure a WebSocket endpoint using Spring WebSocket. After a report is updated (e.g., after AI analysis), send a message through the WebSocket to subscribed clients. Manage WebSocket sessions and subscriptions.",
        "testStrategy": "Connect a client via WebSocket. Trigger a report update (e.g., AI analysis). Verify that the client receives a real-time update via WebSocket.",
        "priority": "high",
        "dependencies": [7],
        "status": "in_progress",
        "notes": "WebSocket starter dependency is present. Endpoint and message broadcasting logic need to be fully implemented."
      },
      {
        "id": 9,
        "title": "Implement Report Management and Comment Functionality",
        "description": "Implement API endpoints for viewing, managing reports, and handling comments.",
        "details": "Create GET endpoints for `/api/reports` (list with filtering/sorting) and `/api/reports/{reportId}` (details). Implement a PUT endpoint for managers to change report status. Implement POST and GET endpoints for comments on a report. Ensure appropriate authorization checks.",
        "testStrategy": "Test report list endpoint with various filters. Test report detail endpoint. Test status change with manager/non-manager users. Test comment creation and retrieval.",
        "priority": "high",
        "dependencies": [2, 3, 4, 7],
        "status": "pending"
      },
      {
        "id": 10,
        "title": "Flutter App - Report Creation Page Enhancement",
        "description": "Complete the Flutter app report creation page with multi-image support, AI analysis integration, and complex subject detection.",
        "details": "Enhance report_create_page_final.dart with: 1) Multi-image selection and preview, 2) Primary image designation via long-press, 3) Complex subject detection when images have different categories, 4) Auto-fill form fields based on AI analysis results, 5) Location services integration with permission handling.",
        "testStrategy": "Test multi-image selection, primary image setting, complex subject detection with diverse images, form auto-fill after AI analysis, and location permission flow.",
        "priority": "high",
        "dependencies": [6, 7],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Enhanced report creation page with multi-image support, primary image selection, complex subject detection, and AI auto-fill functionality."
      },
      {
        "id": 11,
        "title": "Flutter App - Profile Settings Enhancement",
        "description": "Implement comprehensive profile and settings functionality including dark mode, font size, language settings, and notification preferences.",
        "details": "Complete profile feature implementation: 1) Dark mode toggle with real-time theme switching, 2) Font size adjustment with live preview, 3) Language selection, 4) Notification settings with test functionality, 5) My Reports page with filtering, 6) Help and App Info pages, 7) Settings persistence using SharedPreferences.",
        "testStrategy": "Test dark mode switching, font size changes, language selection, notification settings, my reports filtering, and settings persistence across app restarts.",
        "priority": "high",
        "dependencies": [10],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Completed profile settings with ThemeManager, dark mode, font size adjustment, notification settings, and comprehensive settings testing functionality."
      },
      {
        "id": 12,
        "title": "Integration Testing and Production Deployment",
        "description": "Comprehensive integration testing and production deployment preparation.",
        "details": "Complete end-to-end testing: 1) Flutter app to Spring Boot API integration, 2) Kafka message flow testing, 3) AI analysis pipeline validation, 4) WebSocket real-time updates, 5) Database performance testing, 6) Production environment setup with Docker, 7) Security audit and configuration, 8) Monitoring and logging setup.",
        "testStrategy": "End-to-end testing from Flutter app report creation to AI analysis completion. Load testing with multiple concurrent users. Security testing for authentication and data protection.",
        "priority": "medium",
        "dependencies": [3, 4, 8, 9],
        "status": "pending"
      },
      {
        "id": 13,
        "title": "Flutter App - Backend API Integration",
        "description": "Integrate Flutter app with the Spring Boot backend for complete functionality.",
        "details": "Update Flutter app to communicate with backend API: 1) Replace mock data with real API calls to the Spring Boot service, 2) Implement user authentication flow against Spring Security, 3) Connect report creation to backend endpoints, 4) Add real-time WebSocket connections for AI analysis updates, 5) Implement report management features, 6) Add error handling and loading states.",
        "testStrategy": "Test all app features with real backend, verify authentication flow, test report creation and updates, validate WebSocket real-time updates.",
        "priority": "high",
        "dependencies": [12],
        "status": "pending"
      },
      {
        "id": 14,
        "title": "Code Cleanup and Documentation",
        "description": "Clean up legacy code, remove test files, and add comprehensive documentation.",
        "details": "Final code cleanup: 1) Remove all test and mock files not needed for production, 2) Clean up duplicate or legacy code, 3) Add comprehensive API documentation using SpringDoc/Swagger, 4) Create deployment guides, 5) Add code comments and documentation, 6) Organize project structure for production.",
        "testStrategy": "Verify no broken imports after cleanup, validate documentation accuracy, test deployment guides.",
        "priority": "medium",
        "dependencies": [12, 13],
        "status": "pending"
      }
    ],
    "metadata": {
      "created": "2025-07-10T01:00:00.000Z",
      "updated": "2025-07-10T01:00:00.000Z",
      "description": "Tasks for master context - Updated to reflect Spring Boot backend, Kafka integration, and Flutter app status. Aligned with the actual codebase.",
      "totalTasks": 14,
      "completedTasks": 5,
      "inProgressTasks": 2,
      "pendingTasks": 7,
      "completionRate": "36%"
    }
  }
}
