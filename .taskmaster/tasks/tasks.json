{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Infrastructure and Core Services",
        "description": "Set up project repositories for Flutter client, FastAPI gateway, and Python AI worker. Configure Docker Compose for core services: PostgreSQL, Redis, Kafka, Zookeeper.",
        "details": "Create separate repositories (e.g., `flutter-client`, `fastapi-gateway`, `ai-worker`). Write a `docker-compose.yml` file to define and link services: `postgres` (database), `redis` (cache/session), `zookeeper` (Kafka dependency), `kafka` (message queue). Ensure services are configured to communicate within the Docker network. Use environment variables for configuration.",
        "testStrategy": "Verify all services start correctly using `docker-compose up`. Check service logs for errors. Ensure basic connectivity between services (e.g., gateway can connect to DB/Redis).",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Docker Compose configured with Kafka, Zookeeper services. FastAPI router service and Kafka worker implemented.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Design and Implement Database Schema (PostgreSQL)",
        "description": "Design and implement the database schema in PostgreSQL for users, reports, comments, and related data (e.g., categories, statuses).",
        "details": "Create tables: `users` (email, password_hash, role, oauth_provider, oauth_id), `reports` (id, user_id, title, description, latitude, longitude, address, status, category, priority, created_at, updated_at, signature_data), `report_files` (id, report_id, file_url, file_type), `comments` (id, report_id, user_id, content, created_at). Define appropriate relationships (foreign keys) and indices. Use migrations if applicable.",
        "testStrategy": "Connect to the PostgreSQL database and verify that all tables and columns are created as per the schema design. Insert sample data to check constraints and relationships.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement API Gateway and User Authentication/Authorization",
        "description": "Set up the FastAPI API Gateway. Implement user registration (email/password), login, and OAuth login (Google, Kakao). Implement role-based access control.",
        "details": "Use FastAPI with Pydantic for data validation. Implement endpoints for `/register`, `/login`, `/oauth/google`, `/oauth/kakao`. Use libraries like `python-jose` for JWT token generation/verification for session management (stored in Redis). Integrate with OAuth providers using libraries like `authlib`. Implement middleware or decorators for role-based authorization (`user`, `manager`). Store user data in PostgreSQL.",
        "testStrategy": "Test user registration with valid/invalid data. Test email/password login and verify JWT token generation. Test OAuth login flow for Google and Kakao. Verify that endpoints restricted by role are only accessible by users with the correct role.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Report Creation API (Basic Data)",
        "description": "Implement the API endpoint for creating a new report, including handling basic report data (title, description, location, user info).",
        "details": "Create a POST endpoint `/reports` in the FastAPI gateway. This endpoint should receive report data (title, description, lat, lon, address) from the client. Authenticate the user making the request. Store the basic report data in the `reports` table in PostgreSQL, setting initial status (e.g., '접수'). Return the created report ID.",
        "testStrategy": "Send POST requests to `/reports` with valid and invalid report data. Verify that a new report entry is created in the database with the correct user ID and initial status. Check response status codes and data.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement File Upload for Reports",
        "description": "Implement file upload functionality for reports (images, videos) and link uploaded files to the report.",
        "details": "Modify the `/reports` endpoint or create a separate endpoint (e.g., POST `/reports/{report_id}/files`) to handle file uploads. Store files securely on the server's file system or cloud storage. Record file metadata (URL/path, type) in the `report_files` table, linked to the `report_id`. Ensure file type validation and size limits are applied.",
        "testStrategy": "Create a report, then upload various file types (image, video, invalid types) to it. Verify files are stored correctly and `report_files` entries are created. Attempt to upload files to non-existent reports. Check error handling.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Kafka Producer for Image Analysis Requests",
        "description": "Integrate Kafka producer in the API Gateway to send image analysis requests to the `image_requests` topic after a report with images is created/updated.",
        "details": "After a report with attached images is saved (Task 5), extract relevant image file paths/URLs. Use the `confluent-kafka-python` library in the FastAPI gateway to produce messages to the `image_requests` Kafka topic. Each message should contain information needed by the AI worker, such as the report ID and image file path/URL.",
        "testStrategy": "Create a report with images. Monitor the Kafka `image_requests` topic using Kafka tools to verify that messages containing the correct report and image information are being produced.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Kafka producer integrated in FastAPI gateway. Publishes image analysis requests to Kafka topics.",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop AI Worker for Roboflow Analysis via Kafka",
        "description": "Develop the Python AI Worker service to consume messages from the `image_requests` Kafka topic, call the Roboflow AI API for analysis, and produce results to the `analysis_results` Kafka topic.",
        "details": "Create a separate Python application (`ai-worker`). Use `confluent-kafka-python` to consume messages from `image_requests`. For each message, download the image (if necessary) and make an HTTP request to the Roboflow API using the `requests` library, including the necessary API key (managed via environment variables). Parse the Roboflow response to identify detected problems, categories, and confidence scores. Based on the analysis, determine the report category and priority. Produce a new message containing the report ID, analysis results, determined category, and priority to the `analysis_results` Kafka topic.",
        "testStrategy": "Run the AI worker. Create reports with images via the API. Verify the worker consumes messages, calls Roboflow (monitor network traffic/Roboflow logs), and produces messages to the `analysis_results` topic with correct analysis data.",
        "priority": "high",
        "dependencies": [
          1,
          6
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Kafka AI worker implemented with Roboflow integration. Handles image processing and analysis result publishing to Kafka.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate Kafka Consumer in API Gateway for Analysis Results",
        "description": "Integrate Kafka consumer in the API Gateway to process messages from the `analysis_results` topic and update the corresponding report in the database.",
        "details": "Add a Kafka consumer thread or process within the FastAPI gateway using `confluent-kafka-python`. This consumer should subscribe to the `analysis_results` topic. When a message is received, extract the report ID, analysis results, category, and priority. Update the corresponding report entry in the PostgreSQL database with the AI-determined category and priority. Handle potential errors during database updates.",
        "testStrategy": "Ensure the AI worker is producing results. Verify the API gateway consumer is receiving messages from `analysis_results`. Check the database to confirm that reports are updated with the correct category and priority after AI analysis.",
        "priority": "high",
        "dependencies": [
          6,
          7
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "FastAPI gateway with Kafka consumer implemented for processing analysis results and WebSocket notifications.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Real-time Notifications via WebSocket",
        "description": "Implement WebSocket communication in the API Gateway to push real-time updates (AI analysis results, status changes) to the relevant clients.",
        "details": "Use FastAPI's WebSocket capabilities. When a report is updated (e.g., after AI analysis in Task 8, or status change in Task 9), send a WebSocket message to the client(s) subscribed to updates for that report or user. The message should contain the updated report data or notification details. Manage active WebSocket connections, potentially using Redis to map users/reports to connections.",
        "testStrategy": "Connect a client via WebSocket. Create a report with images and wait for AI analysis. Verify that the client receives a real-time update via WebSocket when the report is updated with analysis results. Manually change a report status (once Task 9 is ready) and verify the client receives an update.",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "WebSocket implementation completed in FastAPI gateway for real-time AI analysis result notifications.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Report Management and Comment Functionality",
        "description": "Implement API endpoints for viewing report lists (with filtering, searching, sorting), viewing report details, changing report status (manager only), providing feedback (manager only), and adding/viewing comments.",
        "details": "Create GET endpoints for `/reports` (list) and `/reports/{report_id}` (detail). Implement query parameters for filtering (status, category), searching (keyword in title/description), and sorting (e.g., by date, priority). Implement a PUT endpoint `/reports/{report_id}/status` for managers to change status. Implement a POST endpoint `/reports/{report_id}/feedback` for managers. Implement POST `/reports/{report_id}/comments` and GET `/reports/{report_id}/comments` endpoints. Ensure appropriate authorization checks (user can view their reports, manager can view all/change status/add feedback).",
        "testStrategy": "Test report list endpoint with various filter, search, and sort parameters. Test report detail endpoint. Test status change and feedback endpoints with manager and non-manager users. Test comment creation and retrieval endpoints. Verify data consistency in the database.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Flutter App - Report Creation Page Enhancement",
        "description": "Complete the Flutter app report creation page with multi-image support, AI analysis integration, and complex subject detection.",
        "details": "Enhance report_create_page_final.dart with: 1) Multi-image selection and preview, 2) Primary image designation via long-press, 3) Complex subject detection when images have different categories, 4) Auto-fill form fields based on AI analysis results, 5) Location services integration with permission handling.",
        "testStrategy": "Test multi-image selection, primary image setting, complex subject detection with diverse images, form auto-fill after AI analysis, and location permission flow.",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Enhanced report creation page with multi-image support, primary image selection, complex subject detection, and AI auto-fill functionality.",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Flutter App - Profile Settings Enhancement",
        "description": "Implement comprehensive profile and settings functionality including dark mode, font size, language settings, and notification preferences.",
        "details": "Complete profile feature implementation: 1) Dark mode toggle with real-time theme switching, 2) Font size adjustment with live preview, 3) Language selection, 4) Notification settings with test functionality, 5) My Reports page with filtering, 6) Help and App Info pages, 7) Settings persistence using SharedPreferences.",
        "testStrategy": "Test dark mode switching, font size changes, language selection, notification settings, my reports filtering, and settings persistence across app restarts.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Completed profile settings with ThemeManager, dark mode, font size adjustment, notification settings, and comprehensive settings testing functionality.",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Backend Integration - Database Schema Implementation",
        "description": "Design and implement PostgreSQL database schema for the full application with proper relationships and indices.",
        "details": "Create comprehensive database schema: 1) Users table with OAuth support, 2) Reports table with status tracking and AI analysis results, 3) Report files table for image attachments, 4) Comments table for report feedback, 5) Categories and statuses lookup tables, 6) Proper foreign key relationships and indices for performance.",
        "testStrategy": "Create database schema, insert test data, verify relationships and constraints, test performance with indices.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Comprehensive PostgreSQL database schema created with all tables, relationships, indices, and triggers for production use.",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Backend Integration - FastAPI Gateway Enhancement",
        "description": "Enhance the FastAPI gateway with authentication, report management, and database integration.",
        "details": "Extend router_service.py with: 1) User authentication and JWT token management, 2) Report CRUD operations with database persistence, 3) File upload handling with storage management, 4) Report status management and workflow, 5) Database connection and ORM integration, 6) Enhanced error handling and logging.",
        "testStrategy": "Test user registration/login, report creation/retrieval, file uploads, status updates, database operations, and error scenarios.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "in_progress",
        "notes": "Basic FastAPI routing and Kafka integration completed. Need to add database integration, authentication, and full CRUD operations.",
        "subtasks": [
          {
            "id": "14.1",
            "title": "Add Database Connection and ORM Setup",
            "status": "pending",
            "description": "Set up SQLAlchemy or similar ORM for PostgreSQL connection"
          },
          {
            "id": "14.2",
            "title": "Implement User Authentication Endpoints",
            "status": "pending",
            "description": "Add login, registration, and JWT token management"
          },
          {
            "id": "14.3",
            "title": "Add Report CRUD Operations",
            "status": "pending",
            "description": "Implement create, read, update, delete operations for reports"
          },
          {
            "id": "14.4",
            "title": "Integrate File Upload with Database",
            "status": "pending",
            "description": "Link file uploads to reports and store metadata in database"
          }
        ]
      },
      {
        "id": 15,
        "title": "Integration Testing and Production Deployment",
        "description": "Comprehensive integration testing and production deployment preparation.",
        "details": "Complete end-to-end testing: 1) Flutter app to backend API integration, 2) Kafka message flow testing, 3) AI analysis pipeline validation, 4) WebSocket real-time updates, 5) Database performance testing, 6) Production environment setup with Docker, 7) Security audit and configuration, 8) Monitoring and logging setup.",
        "testStrategy": "End-to-end testing from Flutter app report creation to AI analysis completion. Load testing with multiple concurrent users. Security testing for authentication and data protection.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "notes": "Ready for integration testing once backend database integration is complete.",
        "subtasks": [
          {
            "id": "15.1",
            "title": "Flutter-Backend API Integration",
            "status": "pending",
            "description": "Connect Flutter app to FastAPI backend endpoints"
          },
          {
            "id": "15.2",
            "title": "End-to-End Testing Pipeline",
            "status": "pending",
            "description": "Test complete flow from app to AI analysis"
          },
          {
            "id": "15.3",
            "title": "Production Docker Configuration",
            "status": "pending",
            "description": "Set up production-ready Docker Compose with security"
          },
          {
            "id": "15.4",
            "title": "Monitoring and Logging Setup",
            "status": "pending",
            "description": "Implement application monitoring and log aggregation"
          }
        ]
      },
      {
        "id": 16,
        "title": "Flutter App - Backend API Integration",
        "description": "Integrate Flutter app with the FastAPI backend for complete functionality.",
        "details": "Update Flutter app to communicate with backend API: 1) Replace mock data with real API calls, 2) Implement user authentication flow, 3) Connect report creation to backend endpoints, 4) Add real-time WebSocket connections for AI analysis updates, 5) Implement report management features, 6) Add error handling and loading states.",
        "testStrategy": "Test all app features with real backend, verify authentication flow, test report creation and updates, validate WebSocket real-time updates.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "pending",
        "notes": "Flutter app UI completed but needs backend integration for full functionality.",
        "subtasks": [
          {
            "id": "16.1",
            "title": "HTTP Client Service Implementation",
            "status": "pending",
            "description": "Create HTTP service for API communication"
          },
          {
            "id": "16.2",
            "title": "Authentication Service Integration",
            "status": "pending",
            "description": "Connect login/registration to backend auth"
          },
          {
            "id": "16.3",
            "title": "Report Service Backend Connection",
            "status": "pending",
            "description": "Connect report creation/management to backend API"
          },
          {
            "id": "16.4",
            "title": "WebSocket Real-time Updates",
            "status": "pending",
            "description": "Implement WebSocket connection for AI analysis updates"
          }
        ]
      },
      {
        "id": 17,
        "title": "Code Cleanup and Documentation",
        "description": "Clean up legacy code, remove test files, and add comprehensive documentation.",
        "details": "Final code cleanup: 1) Remove all test and mock files not needed for production, 2) Clean up duplicate or legacy code, 3) Add comprehensive API documentation, 4) Create deployment guides, 5) Add code comments and documentation, 6) Organize project structure for production.",
        "testStrategy": "Verify no broken imports after cleanup, validate documentation accuracy, test deployment guides.",
        "priority": "medium",
        "dependencies": [
          15,
          16
        ],
        "status": "pending",
        "notes": "Final cleanup phase for production readiness.",
        "subtasks": [
          {
            "id": "17.1",
            "title": "Remove Test and Mock Files",
            "status": "pending",
            "description": "Clean up test files and mock services"
          },
          {
            "id": "17.2",
            "title": "API Documentation Generation",
            "status": "pending",
            "description": "Create comprehensive API documentation"
          },
          {
            "id": "17.3",
            "title": "Deployment Documentation",
            "status": "pending",
            "description": "Create production deployment guides"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-29T03:05:18.607Z",
      "updated": "2025-06-29T15:30:00.000Z",
      "description": "Tasks for master context - Updated with comprehensive project status including completed infrastructure, AI/Kafka integration, Flutter app enhancements, and remaining backend integration tasks",
      "totalTasks": 17,
      "completedTasks": 8,
      "inProgressTasks": 1,
      "pendingTasks": 8,
      "completionRate": "47%"
    }
  },
  "duplicate": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Repository Initialization",
        "description": "Initialize the project repository and set up the basic project structure.",
        "details": "Set up a new code repository. Choose a suitable project structure (e.g., based on chosen framework). Include basic configuration files and a README.",
        "testStrategy": "Verify repository is created and initial project files are present.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Setup and Schema Definition",
        "description": "Design and implement the database schema to store file metadata, including hash, file path, file type, and potentially visual similarity features.",
        "details": "Create a database table (e.g., `files`) with columns for `id` (primary key), `hash` (index this column), `filepath`, `filename`, `filesize`, `filetype`, `upload_timestamp`, and potentially columns for image features if needed for visual similarity comparison.",
        "testStrategy": "Verify the database and the `files` table are created with the correct schema and indices.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "File Upload Endpoint and Storage Implementation",
        "description": "Create the API endpoint to handle file uploads and implement the logic to securely store the uploaded files temporarily or permanently.",
        "details": "Develop an HTTP endpoint (e.g., POST /upload) that accepts file uploads. Implement server-side logic to receive the file stream and save it to a designated storage location (e.g., local disk, cloud storage). Ensure proper handling of file names and potential security vulnerabilities.",
        "testStrategy": "Test the endpoint with various file types and sizes to ensure successful upload and storage. Verify files are saved correctly in the storage location.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "File Hashing Utility Implementation",
        "description": "Implement a utility function to calculate the cryptographic hash of an uploaded file's content.",
        "details": "Create a function that takes a file path or file stream as input and returns a unique hash string (e.g., using SHA-256 or MD5 algorithm). Ensure efficient handling of large files by processing them in chunks.",
        "testStrategy": "Calculate hashes for known files and verify the output matches expected hash values. Test with identical and slightly different files to ensure hash uniqueness.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Hash-based Duplicate Check Logic",
        "description": "Implement the core logic to check for existing files in the database based on the calculated file hash.",
        "details": "Develop a function that takes a file hash as input and queries the `files` table. If a record with the matching hash exists, return the existing file's metadata. Otherwise, indicate that no hash duplicate was found.",
        "testStrategy": "Add files with known hashes to the database. Upload a new file with a matching hash and verify the function correctly identifies the duplicate. Upload a unique file and verify it's not flagged as a duplicate.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Image File Type Detection",
        "description": "Implement logic to detect if an uploaded file is an image based on its file type or content.",
        "details": "Use file extension checking and/or MIME type detection to determine if a file is an image (e.g., JPEG, PNG, GIF). Consider using a library for more robust type detection.",
        "testStrategy": "Test with various image file types and non-image file types to ensure accurate detection.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Visual Similarity Calculation Utility",
        "description": "Implement a utility function to calculate a measure of visual similarity between two image files.",
        "details": "Integrate an image processing library (e.g., OpenCV, Pillow with perceptual hashing) to compare two image files. Calculate a similarity score or perceptual hash that can be used to determine if images are visually similar, even if their hashes differ slightly (e.g., due to re-encoding or minor edits).",
        "testStrategy": "Compare identical images, slightly modified images (e.g., resized, compressed), and completely different images. Verify the similarity score or hash difference reflects the visual relationship.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Visual Similarity Duplicate Check Logic (Images)",
        "description": "Implement logic to perform a visual similarity check specifically for image files that are potential duplicates (e.g., after a hash collision or near-miss).",
        "details": "If the hash-based check (Task 5) indicates a potential duplicate or if the file is identified as an image (Task 6), use the visual similarity utility (Task 7) to compare the uploaded image with the existing one(s). Define a threshold for determining visual duplication.",
        "testStrategy": "Upload images that are visually similar but have different hashes. Verify the logic correctly identifies them as duplicates based on the visual similarity threshold. Test with visually different images to ensure they are not flagged.",
        "priority": "medium",
        "dependencies": [
          5,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Integrate Duplicate Check Workflow into Upload Process",
        "description": "Integrate the file upload, hashing, hash-based check, image detection, and visual similarity check logic into a single workflow.",
        "details": "Modify the upload endpoint handler (Task 3) to: 1. Save the file. 2. Calculate its hash (Task 4). 3. Perform a hash-based duplicate check (Task 5). 4. If a hash duplicate is found, flag it. 5. If not a hash duplicate, check if it's an image (Task 6). 6. If it's an image, perform a visual similarity check against existing images (Task 8). 7. Based on the results, determine if the file is a duplicate (either hash or visual).",
        "testStrategy": "Upload files that are exact duplicates (hash match), visually similar images, and unique files. Verify the workflow correctly identifies duplicates based on both criteria and processes unique files correctly.",
        "priority": "high",
        "dependencies": [
          3,
          5,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "User Notification for Duplicate Files",
        "description": "Implement the mechanism to notify the user when a duplicate file is detected during the upload process.",
        "details": "Based on the outcome of the integrated duplicate check workflow (Task 9), provide feedback to the user. This could be an API response indicating the file is a duplicate, including details about the existing file. The specific notification method depends on the system's interface (e.g., JSON response, message queue).",
        "testStrategy": "Upload duplicate files (hash or visual) and verify the system provides the correct notification to the user. Upload unique files and verify no duplicate notification is sent.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T03:31:35.204Z",
      "updated": "2025-06-29T03:32:57.372Z",
      "description": "Tasks for duplicate context"
    }
  },
  "check-service": {
    "tasks": [
      {
        "id": 11,
        "title": "Setup Codebase Analysis Environment",
        "description": "Set up the project environment and codebase access for analysis.",
        "details": "Initialize a project structure. Implement code scanning capabilities to read files from the specified codebase path. This might involve using libraries for file system traversal and reading.",
        "testStrategy": "Verify that the tool can access and read files from a given directory path.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Codebase analysis environment successfully set up. File system traversal and reading capabilities implemented.",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Analyze Database Schema Definitions",
        "description": "Locate and parse database schema definition files (database-structure.md or .sql DDL) within the codebase.",
        "details": "Scan the 'documents' directory or other specified paths for files named 'database-structure.md' or ending with '.sql'. Parse the content to identify table and column definitions if possible, or at least confirm the presence of schema definition.",
        "testStrategy": "Provide test codebases with and without schema files in expected locations and verify correct identification and parsing.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Found and analyzed complete database schema in documents/database-structure.md with comprehensive ERD and DDL definitions for 10 core tables.",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Identify JPA Entity Classes",
        "description": "Scan the codebase to identify classes annotated with @Entity, indicating JPA entity definitions.",
        "details": "Use static code analysis techniques or libraries (e.g., JavaParser for Java) to find classes with the `@Entity` annotation. Record the file paths of identified entity classes.",
        "testStrategy": "Analyze a test codebase containing various classes, some with @Entity, and verify that only entity classes are correctly identified.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Identified 6 JPA entity classes: User, Report, Category, Status, Comment, ReportFile. All properly annotated with @Entity and mapped to database tables.",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Identify JPA Repository Interfaces",
        "description": "Scan the codebase to identify interfaces that extend JpaRepository, indicating JPA repository definitions.",
        "details": "Use static code analysis to find interfaces that inherit from `JpaRepository`. Record the file paths of identified repository interfaces.",
        "testStrategy": "Analyze a test codebase with different interface types, including those extending JpaRepository, and verify correct identification.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Found 2 JPA repository interfaces: UserRepository and ReportRepository. Both extend JpaRepository with custom query methods implemented.",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Verify Repository Method Calls in Service Layer",
        "description": "Analyze service layer classes (@Service) to verify calls to identified JpaRepository methods (save, findById, etc.).",
        "details": "Use static code analysis to find classes annotated with `@Service`. Within these classes, analyze method bodies to detect calls to methods of objects whose types are identified as JpaRepository interfaces. Record the specific method calls and their locations.",
        "testStrategy": "Provide test service classes with and without repository calls and verify accurate detection of calls and their locations.",
        "priority": "high",
        "dependencies": [
          11,
          14
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Verified UserService class with 9 repository.save() calls and multiple query methods. Full CRUD operations implemented with proper transaction management.",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Analyze Database Connection Configuration",
        "description": "Analyze application.properties or application.yml files for database connection configuration.",
        "details": "Scan the codebase for `application.properties` or `application.yml` files. Parse these files to check for properties like `spring.datasource.url`, `spring.datasource.username`, etc.",
        "testStrategy": "Provide test configuration files with and without database connection details and verify correct identification of configuration presence.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Found database configuration in application.properties. PostgreSQL connection settings present but commented out, requiring activation for production use.",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Identify External AI Service Configuration",
        "description": "Identify configuration blocks (e.g., dictionaries) containing external AI service API keys and URLs.",
        "details": "Scan code files for specific variable names or structures (like `WORKFLOW_CONFIG`) that typically hold external service credentials and endpoints. Identify and record the presence and location of such configurations.",
        "testStrategy": "Analyze test codebases with and without defined AI configuration blocks and verify correct identification.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Found complete Roboflow AI service configuration with environment variable support: api.key, workspace, project, version, and api.url settings.",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Verify External AI API Calls",
        "description": "Analyze code to verify actual HTTP API calls (e.g., using 'requests' library) to external AI services based on identified configuration.",
        "details": "Use static code analysis to find code patterns indicating HTTP requests (e.g., `requests.post`, `HttpClient.send`). Correlate these calls with the identified AI service URLs from task 17 to confirm actual API interaction.",
        "testStrategy": "Analyze test code with and without HTTP calls targeting configured AI endpoints and verify accurate detection.",
        "priority": "high",
        "dependencies": [
          11,
          17
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Verified RoboflowService class with complete HTTP API implementation using RestTemplate, multipart file upload, retry logic, and circuit breaker pattern.",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Analyze Dynamic AI API Call Logic",
        "description": "Analyze code for logic that dynamically calls different AI APIs based on input data (e.g., from a message queue).",
        "details": "Analyze code flow, particularly around message queue consumers or data processing entry points. Look for conditional logic (if/else, switch) that selects an API endpoint or configuration based on a data field (e.g., 'category').",
        "testStrategy": "Provide test code with dynamic API dispatch logic based on input data and verify correct identification of this pattern.",
        "priority": "medium",
        "dependencies": [
          11,
          18
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Found dynamic AI processing logic with scenario-based mock responses, confidence-based priority determination, and Korean localization mapping.",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Generate Analysis Report",
        "description": "Generate a final report in Markdown format summarizing the analysis findings for DB and AI integration, providing evidence (code locations), and suggesting next steps.",
        "details": "Compile the results from tasks 12-19. Determine the implementation status ('설계만 된 상태', '부분 구현', '구현 완료') for DB and AI features based on the Definition of Done. Format the output as a Markdown document including summaries, specific file/line references as evidence, and actionable suggestions for incomplete parts.",
        "testStrategy": "Run the analysis on test codebases representing different implementation statuses (designed, partial, complete) and verify that the generated Markdown report accurately reflects the status, provides correct evidence, and suggests appropriate next steps.",
        "priority": "high",
        "dependencies": [
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19
        ],
        "status": "completed",
        "completedAt": "2025-06-29T15:45:00.000Z",
        "notes": "Generated comprehensive analysis report at DATABASE_AI_INTEGRATION_ANALYSIS.md. DB integration: 90% complete, AI integration: 95% complete. Both ready for production with minor configuration activation needed.",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T03:38:16.965Z",
      "updated": "2025-06-29T15:45:00.000Z",
      "description": "Tasks for check-service context - Completed comprehensive codebase analysis for database and AI integration verification",
      "totalTasks": 10,
      "completedTasks": 10,
      "inProgressTasks": 0,
      "pendingTasks": 0,
      "completionRate": "100%"
    }
  },
  "map-dev": {
    "tasks": [
      {
        "id": 1,
        "title": "Configure Project Dependencies and QueryDSL Setup",
        "description": "Add necessary dependencies for QueryDSL and Jakarta Validation to the build.gradle file. Configure the Gradle task to automatically generate QueryDSL Q-Type classes.",
        "details": "Update `build.gradle`:\n- Add `querydsl-jpa`, `querydsl-apt` dependencies.\n- Add `jakarta.validation:jakarta.validation-api` and implementation (e.g., `org.hibernate.validator:hibernate-validator`).\n- Configure `compileQuerydsl` task for Q-Type generation, specifying the output directory.",
        "testStrategy": "Verify that dependencies are added correctly and the `compileQuerydsl` task runs successfully, generating Q-Type classes in the specified directory.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define Immutable DTOs with Validation",
        "description": "Create immutable Data Transfer Objects (DTOs) using Java `record` for key request and response payloads, starting with Report-related operations. Include `jakarta.validation.constraints` annotations for input validation.",
        "details": "Create DTO classes (e.g., `ReportCreateRequest`, `ReportSummaryDto`) in the `com.jeonbuk.report.dto` package.\n- Use `record` type for immutability.\n- Add validation annotations like `@NotBlank`, `@Size`, `@NotNull` to request DTO fields.\n\nExample (from PRD):\n```java\npublic record ReportCreateRequest(\n    @NotBlank String title,\n    @Size(max = 4000) String content,\n    @NotNull Long categoryId\n) {}\n```",
        "testStrategy": "Review created DTO classes to ensure they are `record` types, contain necessary fields for corresponding API endpoints, and have appropriate validation annotations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Separate Repository Interfaces for QueryDSL",
        "description": "For Repositories requiring complex dynamic queries (e.g., ReportRepository), define a custom interface that extends the base JpaRepository and declares the QueryDSL-based methods.",
        "details": "Create a new interface (e.g., `ReportRepositoryCustom`) in the same package as the main Repository interface.\n- Declare methods for complex queries (e.g., `Page<ReportSummaryDto> searchReports(ReportSearchCondition condition, Pageable pageable);`).\n- Update the main Repository interface (e.g., `ReportRepository`) to extend both `JpaRepository<Entity, ID>` and the new custom interface (`ReportRepositoryCustom`).\n\nExample (from PRD):\n```java\npublic interface ReportRepository extends JpaRepository<Report, Long>, ReportRepositoryCustom {}\npublic interface ReportRepositoryCustom {\n    Page<ReportSummaryDto> searchReports(ReportSearchCondition condition, Pageable pageable);\n}\n```",
        "testStrategy": "Verify that custom interfaces are created and the main Repository interfaces correctly extend them.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement QueryDSL Repository Methods",
        "description": "Implement the custom Repository interfaces using QueryDSL. Create implementation classes (e.g., `ReportRepositoryCustomImpl`) that use `JPAQueryFactory` to build and execute dynamic queries, focusing initially on the Report search functionality.",
        "details": "Create implementation classes for the custom interfaces (e.g., `ReportRepositoryCustomImpl`).\n- Annotate the implementation class with `@Repository`.\n- Inject `JPAQueryFactory`.\n- Implement the methods declared in the custom interface using QueryDSL Q-Types and `JPAQueryFactory`.\n- Handle dynamic conditions based on input parameters.\n- Ensure pagination and sorting are handled correctly.\n\nExample (from PRD):\n```java\n@Repository\npublic class ReportRepositoryCustomImpl implements ReportRepositoryCustom {\n    private final JPAQueryFactory queryFactory;\n    // ... constructor\n    @Override\n    public Page<ReportSummaryDto> searchReports(ReportSearchCondition condition, Pageable pageable) {\n        QReport report = QReport.report;\n        // QueryDSL query logic...\n        // ... return Page object\n    }\n    // ... helper methods for conditions\n}\n```",
        "testStrategy": "Review the implementation classes to ensure they use `JPAQueryFactory`, Q-Types, and correctly implement the dynamic query logic specified in the custom interfaces.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement DTO-Domain Conversion Logic",
        "description": "Implement logic to convert between DTOs and Domain objects. This can be done using static factory methods on Domain/DTO classes, builder patterns, or dedicated converter classes.",
        "details": "Add static methods like `fromDto(Dto dto)` or `toDto(Domain domain)` to Domain or DTO classes.\nAlternatively, create dedicated converter classes (e.g., `ReportConverter`) with methods like `toDomain(ReportCreateRequest dto)` and `toDto(Report domain)`.\nAvoid using libraries like ModelMapper or MapStruct initially, as per PRD guidance.",
        "testStrategy": "Verify that conversion methods/classes are created and correctly map fields between DTOs and Domain objects.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Refactor Service Layer to Use DTOs and QueryDSL Repositories",
        "description": "Refactor the Service layer to accept DTOs from the Controller, convert them to Domain objects for business logic processing, interact with the Repository (including QueryDSL methods), and convert results back to DTOs before returning.",
        "details": "Update Service method signatures to use DTOs as input parameters and return types where applicable.\n- Use the DTO-Domain conversion logic (Task 5) within Service methods.\n- Call the appropriate Repository methods, including the new QueryDSL methods (Task 4).\n- Ensure `@Transactional` annotation is correctly applied for transaction management.",
        "testStrategy": "Review Service classes to ensure they interact with DTOs, perform conversion, use the correct Repository methods, and manage transactions.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Refactor Controller Layer to Use DTOs and Validation",
        "description": "Refactor the Controller layer to strictly handle HTTP requests and responses using DTOs. Add `@Valid` annotation to request DTO parameters to trigger validation. Remove any direct references to Domain objects.",
        "details": "Update Controller method signatures to accept Request DTOs and return Response DTOs (or `ResponseEntity` containing DTOs).\n- Add `@Valid` annotation to method parameters that are Request DTOs.\n- Call the corresponding Service methods (Task 6).\n- Handle potential validation errors (e.g., using `@ExceptionHandler` or Controller Advice).\n- Ensure no Domain objects are directly used or exposed by the Controller.",
        "testStrategy": "Review Controller classes to confirm they only use DTOs for input/output, have `@Valid` on request DTOs, and delegate business logic entirely to the Service layer.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Develop Repository Integration Tests for QueryDSL",
        "description": "Write integration tests for the Repository layer using `@DataJpaTest` to verify that the QueryDSL methods (Task 4) function correctly, including dynamic filtering, pagination, and sorting.",
        "details": "Create test classes for Repositories (e.g., `ReportRepositoryTest`).\n- Use `@DataJpaTest` annotation.\n- Inject the Repository interface.\n- Write test cases to cover different scenarios for QueryDSL methods (e.g., searching with various filter combinations, testing pagination boundaries, verifying sorting).",
        "testStrategy": "Run `@DataJpaTest` tests to ensure QueryDSL queries return the expected results for various conditions and pagination/sorting parameters.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Service Unit Tests",
        "description": "Write unit tests for the Service layer to verify the core business logic, DTO-Domain conversion handling, and transaction management. Mock the Repository layer.",
        "details": "Create test classes for Services (e.g., `ReportServiceTest`).\n- Use Mockito to mock the Repository dependencies.\n- Write test cases to verify that Service methods correctly implement business rules, handle input DTOs, produce output DTOs, and interact with the mocked Repository as expected.\n- Test transaction boundaries if applicable.",
        "testStrategy": "Run unit tests to ensure Service methods execute business logic correctly and handle DTOs and transactions as designed.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Develop Controller Unit Tests",
        "description": "Write unit tests for the Controller layer using MockMvc or similar framework to verify request mapping, DTO handling, input validation (`@Valid`), and correct interaction with the Service layer (which should be mocked).",
        "details": "Create test classes for Controllers (e.g., `ReportControllerTest`).\n- Use `@WebMvcTest` or configure MockMvc manually.\n- Use Mockito to mock the Service dependency.\n- Write test cases to verify:\n    - Correct HTTP method and path mapping.\n    - Request DTOs are correctly received.\n    - `@Valid` annotation triggers validation errors for invalid input.\n    - Service methods are called with the correct parameters.\n    - Response DTOs and HTTP status codes are correct.",
        "testStrategy": "Run unit tests to ensure Controller endpoints handle requests and responses using DTOs, perform validation, and correctly delegate to the Service layer.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T11:27:33.877Z",
      "updated": "2025-06-29T11:42:01.199Z",
      "description": "Tasks for map-dev context"
    }
  },
  "refactor1": {
    "tasks": [
      {
        "id": 1,
        "title": "Integrate Secure Storage and Image Picker Libraries",
        "description": "Integrate necessary third-party libraries for secure storage and image handling as required by the PRD.",
        "details": "Add `flutter_secure_storage` for secure token storage and an image picker library (e.g., `image_picker`) to the project dependencies. Ensure compatibility with target platforms (Android/iOS). Run `flutter pub get`.",
        "testStrategy": "Verify that the libraries are added to `pubspec.yaml` and can be imported without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Secure Authentication Token Storage",
        "description": "Implement the logic to securely store authentication tokens (Access and Refresh tokens) on the device after a successful login.",
        "details": "Use `flutter_secure_storage` to write the received tokens to the device's secure storage (Keychain on iOS, EncryptedSharedPreferences on Android). Ensure tokens are stored immediately upon successful authentication.",
        "testStrategy": "Perform a successful login and verify that tokens are stored securely using platform-specific tools or debugging techniques (without exposing sensitive data).",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Persistent Login State on App Launch",
        "description": "Implement logic to check for stored tokens on app launch and automatically restore the user's login session if valid tokens are found.",
        "details": "On application startup, attempt to read tokens from secure storage. If tokens exist, validate them (e.g., check expiry, attempt token refresh if a refresh token is available). If validation/refresh is successful, set the user's authentication state to logged in. Handle cases where tokens are expired or invalid, requiring the user to log in again.",
        "testStrategy": "Log in, close the app completely (terminate), and reopen it. Verify that the user is automatically logged in without needing to re-enter credentials. Test with valid and expired/invalid tokens (simulated or actual).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add Filter UI to Main Report List Screen",
        "description": "Add the filter icon and associated UI elements (e.g., modal, bottom sheet) to the main 'Report' tab's list view, mirroring the existing UI in 'My Profile'.",
        "details": "Modify the UI layout of the main report list screen (`ReportListScreen`). Add a filter button/icon, typically in the app bar or above the list. Design or reuse the UI for selecting filter criteria (status, category) that appears when the filter button is tapped.",
        "testStrategy": "Navigate to the main report list screen and verify that the filter icon is present and tapping it displays the filter selection UI.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Report List Filtering Logic",
        "description": "Implement the logic to filter the main report list based on the selected status and category criteria from the new filter UI.",
        "details": "Connect the filter selection UI to the data fetching/display logic for the main report list. When filter criteria are applied, update the list query or filter the displayed data locally based on the selected status and category values. Reuse the existing filtering logic implemented for the 'My Reports' list.",
        "testStrategy": "Apply different filter combinations (status, category). Verify that the displayed reports correctly match the selected criteria. Test edge cases like selecting 'All' or combinations with zero results.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Add Profile Picture Display Area to Profile Screen",
        "description": "Add a dedicated area for displaying the user's profile picture on the 'My Profile' screen.",
        "details": "Modify the UI layout of the 'My Profile' screen. Include an `Image` widget or similar component to display the profile picture. Initially, this should show a default placeholder image. Make this area tappable to trigger the photo change functionality.",
        "testStrategy": "Navigate to the 'My Profile' screen and verify that the profile picture area with a default image is visible and tappable.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Profile Picture Selection (Camera/Gallery)",
        "description": "Implement the functionality to allow users to select a profile picture using either the device's camera or photo gallery.",
        "details": "When the profile picture area is tapped, present a choice dialog/sheet offering 'Take Photo' (using camera) or 'Choose from Gallery'. Use the integrated image picker library (`image_picker`) to handle the native camera and gallery interactions and retrieve the selected image file path.",
        "testStrategy": "Tap the profile picture area. Verify that the camera/gallery options are presented. Select 'Take Photo' and confirm the camera opens. Select 'Choose from Gallery' and confirm the gallery opens. Select an image and verify the app receives the image data/path.",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Profile Picture Resizing and Compression",
        "description": "Implement image processing logic to resize and compress the selected profile picture before uploading it to the server.",
        "details": "After an image is selected via the image picker, use an image processing library (e.g., `image` or built-in capabilities) to resize the image to a reasonable dimension (e.g., max 500x500 pixels) and compress its quality to reduce file size. This minimizes server load and data usage.",
        "testStrategy": "Select a large image. Process it and verify that the resulting image file size is significantly smaller and dimensions are within the specified limits. Check image quality after compression.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Profile Picture Upload API Integration",
        "description": "Implement the API call to upload the processed profile picture image data to the backend server.",
        "details": "Create or use an existing API client method to handle the image upload. This typically involves sending the processed image file data as part of a multipart form request to the designated server endpoint. Handle success and failure responses from the server.",
        "testStrategy": "Select and process an image, then attempt to upload it. Monitor network requests to confirm the image data is sent correctly. Verify the server responds with a success status. Check the backend/database (if accessible) to confirm the image was received and stored.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Display of User Profile Picture",
        "description": "Implement fetching and displaying the user's current profile picture from the server on the 'My Profile' screen.",
        "details": "When the 'My Profile' screen loads, fetch the user's profile data, including the URL of their profile picture, from the server (likely via a user profile API endpoint). Load and display this image in the profile picture area. Handle loading states and display the default image if no profile picture is set or fetching fails.",
        "testStrategy": "Upload a profile picture (Task 9). Navigate away from and back to the 'My Profile' screen. Verify that the newly uploaded picture is displayed correctly. Test with a user who has no profile picture set.",
        "priority": "medium",
        "dependencies": [
          6,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T14:23:09.331Z",
      "updated": "2025-06-29T14:24:18.738Z",
      "description": "Tasks for refactor1 context"
    }
  },
  "refactor2": {
    "tasks": [
      {
        "id": 1,
        "title": "Apply Custom Font and Standardize Terminology",
        "description": "Apply the NotoSansKR font as the default theme font and standardize terminology used throughout the app for improved accessibility and consistency.",
        "details": "Modify the app's theme definition in Flutter to uncomment and use `NotoSansKR` as the primary font family. Review all user-facing text strings (labels, buttons, messages) and ensure consistent terminology (e.g., '보고서' vs '신고', '처리중' vs '처리 중') based on the PRD's suggestion.",
        "testStrategy": "Visually inspect various screens to confirm that the NotoSansKR font is applied correctly. Review key UI elements and text content to verify consistent terminology usage.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Integrate Naver Map API for Location Display",
        "description": "Integrate the `flutter_naver_map` widget into the application to display report locations using Naver Maps.",
        "details": "Obtain and configure necessary Naver Map API keys. Implement a screen or widget that utilizes the `flutter_naver_map` package to display a map. The map should be able to center on and display the location specified by a report's latitude and longitude coordinates.",
        "testStrategy": "Verify that the map view loads without errors. Confirm that providing valid latitude and longitude coordinates correctly centers the map and/or places a marker at the specified location.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Enhance Report Form UI with GPS and Signature Input",
        "description": "Enhance the `ReportFormScreen` UI to include fields for displaying the current GPS location and capturing a user's signature.",
        "details": "Use the `geolocator` package to fetch the device's current GPS coordinates (latitude and longitude) and display them in a non-editable text field on the form. Integrate the `signature` widget to provide a drawing area for users to capture their signature as image data.",
        "testStrategy": "Verify that the GPS coordinates field populates automatically with the current location data. Test the signature pad to ensure drawing is possible and the captured signature data is correctly generated.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Optimize Report Form UI/UX for Speed",
        "description": "Optimize the layout and user flow of the `ReportFormScreen` to facilitate report completion within the 3-minute target.",
        "details": "Review the current arrangement of input fields, buttons, and other UI elements on the report form. Rearrange them based on the typical user workflow and importance to minimize steps and cognitive load. Ensure easy access to frequently used or critical fields.",
        "testStrategy": "Conduct timed user walkthroughs or simulations of the report creation process to verify if it can be completed comfortably within 3 minutes. Gather user feedback on the form's usability and efficiency.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Flutter Report Data Transmission to Backend",
        "description": "Implement the client-side logic in Flutter to gather all report data (text, location, signature, images) and transmit it to the backend.",
        "details": "Create or update the `Report` data model to include all necessary fields: text inputs (title, description, category), location data (latitude, longitude), signature data (as image bytes or path), and image files. Use a suitable networking library (e.g., `dio`) to construct a `multipart/form-data` request containing all these data points and send it to the designated Spring Boot backend endpoint (`ReportController`).",
        "testStrategy": "Create a test report filling in all available fields (text, location, attach image, sign). Submit the report and use network debugging tools (e.g., Charles, Wireshark) to inspect the outgoing request, ensuring it is `multipart/form-data` and contains all expected data correctly formatted.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Backend Report Data Processing and Storage",
        "description": "Implement the Spring Boot backend logic to receive the `multipart/form-data` report submission, process the data, save text fields to the database, and store files (images, signature) in MinIO storage, recording file metadata.",
        "details": "Update the `ReportController` to correctly handle incoming `multipart/form-data` requests. Extract the text-based report data and persist it to the `reports` table following the `database/schema.sql`. For attached image files and signature data, receive the file streams, upload them to the configured MinIO object storage, and save the resulting file paths or identifiers along with other relevant metadata (like report ID, file type) into the `report_files` table.",
        "testStrategy": "Submit a report from the Flutter client (Task 5). Monitor the backend logs for successful request processing. Verify that a new entry is created in the `reports` table with correct text data. Confirm that files are uploaded to MinIO and corresponding records are created in the `report_files` table linking back to the report.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement AI Integration for Automatic Form Filling",
        "description": "Implement the logic within `ReportFormScreen` to trigger backend AI analysis upon image selection and automatically populate relevant form fields with the analysis results.",
        "details": "When a user selects or captures an image, send this image data (or a reference/path) to the backend AI analysis service endpoint (e.g., calling a service that wraps `analyze_image.py`). Upon receiving the response from the backend, which should contain structured data like detected category and extracted text (OCR), update the corresponding input fields (e.g., '카테고리', '설명') on the `ReportFormScreen` with the AI-provided values.",
        "testStrategy": "Select an image known to contain objects or text that the AI service is designed to recognize. Verify that the AI analysis is triggered and that the category and description fields on the form are automatically populated with the expected results from the AI.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Offline Report Storage and Sync",
        "description": "Implement the offline data storage and synchronization logic using `Hive` and `connectivity_plus`.",
        "details": "Use `connectivity_plus` to actively monitor the device's network status. If the network is unavailable when a user attempts to submit a report, intercept the submission and save the report data locally using the `Hive` key-value store. Implement a background process or a listener that detects when network connectivity is restored. This process should iterate through reports stored in `Hive`, attempt to submit them to the backend (reusing the logic from Task 5), and remove successfully submitted reports from `Hive`.",
        "testStrategy": "Disable network connectivity on the test device. Create and attempt to submit a report; verify it is saved locally in Hive. Re-enable network connectivity and verify that the saved report is automatically submitted to the backend and subsequently removed from Hive.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build Backend Real-time Notification Pipeline (Kafka/WebSocket)",
        "description": "Build the backend real-time notification pipeline using Kafka and WebSocket.",
        "details": "Modify the `ReportService` (or the component responsible for saving reports in Task 6) to publish a message to a designated Kafka topic (e.g., `report.created`) whenever a report is successfully saved to the database. The message should contain essential information like the new report's ID. Develop a separate `NotificationService` component that subscribes to this Kafka topic. Upon receiving a message, use `spring-boot-starter-websocket` to broadcast a real-time notification message to all connected WebSocket clients, specifically targeting the admin dashboard.",
        "testStrategy": "Create a report via the mobile app. Verify that a message is published to the Kafka topic using Kafka monitoring tools. Confirm that the `NotificationService` consumes the message and logs or indicates that a WebSocket message is being sent to connected clients.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Web Dashboard Real-time Report Updates",
        "description": "Implement the client-side logic in the Flutter web admin dashboard to connect to the backend WebSocket and handle real-time report notifications.",
        "details": "In the admin web application, establish a WebSocket connection to the backend endpoint exposed by the `NotificationService` (Task 9). Implement a listener to receive incoming messages over the WebSocket. When a message indicating a new report is received, trigger an action such as automatically refreshing the list of reports displayed on the dashboard or showing a visual notification (e.g., a banner or counter update) to the administrator.",
        "testStrategy": "Open the admin dashboard in a web browser. Create a new report using the mobile app. Verify that the admin dashboard receives a real-time update (e.g., the new report appears in the list without manual refresh, or a notification is displayed) within the target 5-second window.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Improve UI Design with Regional Branding",
        "description": "Apply 전북특별자치도 branding guidelines (colors, logo, public sector app style) to the application's UI for regional familiarity and trust.",
        "details": "Update the application's visual theme, including primary and accent colors, app bar styles, button appearances, and potentially incorporate the regional logo where appropriate. Refer to any provided branding guidelines or publicly available style guides for 전북특별자치도 or similar public sector applications to ensure consistency and adherence.",
        "testStrategy": "Conduct a visual review of all major screens in the application. Compare the implemented design elements (colors, fonts, spacing, component styles) against the specified branding guidelines to ensure accurate and consistent application.",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T14:37:18.820Z",
      "updated": "2025-06-29T14:38:01.192Z",
      "description": "Tasks for refactor2 context"
    }
  },
  "ai-agent": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Spring Boot Project and Infrastructure Configuration",
        "description": "Initialize the Spring Boot project, configure necessary dependencies (Spring Web, Spring Data JPA, Kafka client, etc.), set up the database connection using the existing schema, and configure Kafka producers/consumers for logging.",
        "details": "Use Spring Boot Initializr to create a new project. Add dependencies for web, JPA, database driver (e.g., PostgreSQL, MySQL based on schema), Kafka, and potentially Lombok. Configure application.properties or application.yml for database connection details and Kafka bootstrap servers. Ensure the existing `database/schema.sql` can be applied.",
        "testStrategy": "Verify project builds successfully. Confirm database connection is established. Send a test message to Kafka topic configured for logging and verify it's received.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement OpenRouter.ai API Client",
        "description": "Develop a client module to interact with the OpenRouter.ai API, specifically for the `qwen/qwen2.5-vl-72b-instruct:free` model. This client should handle API requests and responses.",
        "details": "Create a service or component (e.g., `OpenRouterApiClient`) using Spring's `RestTemplate` or `WebClient`. Implement methods for sending prompts to the `https://openrouter.ai/qwen/qwen2.5-vl-72b-instruct:free` endpoint and parsing the JSON response. Handle API key authentication. Consider rate limiting and error handling for API calls.",
        "testStrategy": "Write unit tests for the client methods, mocking the external API response. Write integration tests to call the actual OpenRouter.ai API with test data and verify successful response parsing.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Roboflow API Client",
        "description": "Develop a client module to interact with the Roboflow API. This client will be responsible for sending data to the selected Roboflow model for object analysis.",
        "details": "Create a service or component (e.g., `RoboflowApiClient`) using `RestTemplate` or `WebClient`. Implement a method to send data (e.g., image URL or base64) to a specified Roboflow model endpoint. Handle API key authentication and parse the analysis results.",
        "testStrategy": "Write unit tests mocking the Roboflow API response. Write integration tests to call a test Roboflow model (if available) with sample data and verify the response structure.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Integrated AI Agent: Data Parsing and Analysis",
        "description": "Implement the core logic for the Integrated AI Agent to receive diverse input data, use the OpenRouter.ai client to parse and analyze it, extracting key information required for Roboflow model routing.",
        "details": "Create a service (e.g., `IntegratedAiAgentService`). Implement a method `analyzeInput(InputData data)` that takes the input, formats a prompt for the `qwen/qwen2.5-vl-72b-instruct:free` model via the `OpenRouterApiClient`, sends the request, and parses the AI's response to extract structured information (e.g., object type, damage type, environment). Define the expected output format from the AI.",
        "testStrategy": "Write unit tests with various input data formats and mock AI responses to ensure correct parsing and extraction of information. Use integration tests with the actual OpenRouter.ai API and sample data.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Integrated AI Agent: Roboflow Model Routing Decision",
        "description": "Implement the logic within the Integrated AI Agent to determine the most suitable Roboflow model based on the analyzed input data. The routing logic should be designed for easy expansion.",
        "details": "Within the `IntegratedAiAgentService`, add a method `determineRoboflowModel(AnalyzedData analyzedData)`. This method will use the structured data from the analysis step (Task 4) to look up or decide which Roboflow model ID/endpoint is appropriate. Use a configuration-driven approach (e.g., a map or rules engine) to make it extensible. Return the selected model identifier.",
        "testStrategy": "Write unit tests covering different analyzed data scenarios to ensure the correct Roboflow model is selected according to predefined rules. Test the extensibility by adding a new rule/model mapping.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Validation Checking AI Agent: Data Validation",
        "description": "Implement the core logic for the Validation Checking AI Agent to validate the data parsed and analyzed by the Integrated AI Agent using the OpenRouter.ai API.",
        "details": "Create a service (e.g., `ValidationAiAgentService`). Implement a method `validateData(AnalyzedData analyzedData)` that takes the structured data from Task 4, formats a validation prompt for the `qwen/qwen2.5-vl-72b-instruct:free` model, sends the request via `OpenRouterApiClient`, and parses the AI's response to determine if the data is valid. Handle cases of unexpected values, format errors, or logical inconsistencies.",
        "testStrategy": "Write unit tests with various valid and invalid analyzed data inputs and mock AI responses to ensure correct validation outcomes (pass/fail) and error message generation. Use integration tests with the actual OpenRouter.ai API.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Validation Checking AI Agent: Routing Decision Validation",
        "description": "Implement the logic within the Validation Checking AI Agent to validate the Roboflow model routing decision made by the Integrated AI Agent using the OpenRouter.ai API.",
        "details": "Within the `ValidationAiAgentService`, add a method `validateRoutingDecision(AnalyzedData analyzedData, String selectedModelId)`. This method will use the analyzed data (Task 4) and the selected model ID (Task 5), format a prompt for the AI to check if the decision is appropriate based on implicit or explicit rules, and parse the AI's validation response.",
        "testStrategy": "Write unit tests covering scenarios where the selected model is correct or incorrect for the given analyzed data, mocking AI responses to verify validation results. Use integration tests with the actual OpenRouter.ai API.",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Transaction Management for Core Process",
        "description": "Implement the core transaction management mechanism to ensure the entire process (parsing, analysis, routing decision, data validation, routing validation) is treated as a single atomic unit.",
        "details": "Use Spring's `@Transactional` annotation on the main service method that orchestrates the process. Ensure that database operations (if any are added within the transaction scope) and potentially other resource operations are configured to participate in the transaction. Design the workflow such that validation failures trigger exceptions that cause transaction rollback.",
        "testStrategy": "Write integration tests that simulate validation failures at different stages within the transaction and verify that no partial state changes are persisted (e.g., no data saved to DB, no external calls made after failure if possible within transaction boundaries).",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Integrate AI Agents, Validation, and Roboflow into Workflow",
        "description": "Orchestrate the entire workflow: receive input, call Integrated AI Agent for parsing/analysis and routing decision, call Validation Checking AI Agent for data and routing validation, handle validation results (rollback on failure), and call the selected Roboflow model via the Roboflow API client if validation passes.",
        "details": "Create a main service (e.g., `RoutingService`). Implement a method `processInput(InputData data)` annotated with `@Transactional` (from Task 8). Inside this method, call `IntegratedAiAgentService` methods (Tasks 4 & 5), then call `ValidationAiAgentService` methods (Tasks 6 & 7). If validation passes, call `RoboflowApiClient` (Task 3) with the selected model ID and input data. If validation fails, throw a specific exception.",
        "testStrategy": "Write end-to-end integration tests covering all user scenarios (normal flow, invalid data, incorrect routing decision). Verify successful processing and Roboflow call in the success scenario. Verify transaction rollback and appropriate error responses in failure scenarios.",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Error Handling and Kafka Logging",
        "description": "Implement comprehensive error handling across the system and integrate Kafka logging for key events, errors, and transaction outcomes.",
        "details": "Implement exception handling for API errors (OpenRouter, Roboflow), validation errors, and unexpected system errors. Ensure that validation failures within the transaction trigger rollbacks (Task 8). Use the Kafka configuration from Task 1 to send structured log messages for input received, analysis results, routing decisions, validation outcomes (success/failure with details), Roboflow calls, transaction commit/rollback, and any errors encountered. Refer to `documents/feature-kafka-logging-mongodb.md` for logging requirements.",
        "testStrategy": "Test error scenarios (API failures, invalid input, validation failures) and verify that appropriate error responses are returned and detailed error logs are sent to Kafka. Verify that successful runs also generate expected log messages in Kafka.",
        "priority": "medium",
        "dependencies": [
          1,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T17:59:51.648Z",
      "updated": "2025-06-29T18:00:19.791Z",
      "description": "Tasks for ai-agent context"
    }
  },
  "alert-service": {
    "tasks": [
      {
        "id": 11,
        "title": "Project Setup and Core Dependencies",
        "description": "Set up the basic Spring Boot project structure and include necessary dependencies for web, database access, and external API calls.",
        "details": "Initialize a Spring Boot project. Add dependencies for `spring-boot-starter-web`, `spring-boot-starter-data-jpa` (or relevant DB access), and potentially HTTP client libraries like `spring-webflux` or `okhttp` for external API calls. Configure basic application properties.",
        "testStrategy": "Verify project compiles and basic Spring context loads successfully.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement OpenRouter.ai API Client",
        "description": "Develop a client service to interact with the OpenRouter.ai API, specifically for the `qwen/qwen2.5-vl-72b-instruct:free` model.",
        "details": "Create a dedicated service class (e.g., `OpenRouterApiClient`) using a suitable HTTP client. Implement methods to send requests to the OpenRouter API endpoint (`https://openrouter.ai/api/v1/chat/completions`) with the specified model and handle responses. Include API key management (e.g., via application properties). Pseudo-code: `POST https://openrouter.ai/api/v1/chat/completions` with payload `{ model: 'qwen/qwen2.5-vl-72b-instruct:free', messages: [...] }`.",
        "testStrategy": "Write integration tests to call the OpenRouter API client with mock or actual data and verify successful response parsing.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Project Dependencies and API Key Configuration",
            "description": "Add necessary dependencies for an HTTP client library (e.g., Apache HttpClient, OkHttp, Spring WebClient) and JSON processing (e.g., Jackson, Gson) to the project. Configure a mechanism for securely loading the OpenRouter API key (e.g., environment variable, application properties).",
            "dependencies": [],
            "details": "Choose a suitable HTTP client library based on project context (synchronous vs. asynchronous, existing libraries). Add the library and a JSON processing library dependency to the build file (pom.xml, build.gradle). Define a configuration property or environment variable name for the API key.",
            "status": "pending",
            "testStrategy": "Verify dependencies are added correctly and the API key configuration mechanism is accessible (e.g., load a dummy value)."
          },
          {
            "id": 2,
            "title": "Create Basic OpenRouter API Client Class Structure",
            "description": "Create the `OpenRouterApiClient` class. Initialize the chosen HTTP client instance within this class, potentially using dependency injection or a factory.",
            "dependencies": [
              1
            ],
            "details": "Define the `OpenRouterApiClient` class. Add a private field for the HTTP client instance. Initialize the client in the constructor or an initialization method. Consider making the base API URL (`https://openrouter.ai/api/v1/`) a constant or configurable property.",
            "status": "pending",
            "testStrategy": "Instantiate the `OpenRouterApiClient` class and verify that the internal HTTP client instance is successfully initialized."
          },
          {
            "id": 3,
            "title": "Implement Chat Completions Request Method",
            "description": "Add a method (e.g., `completeChat`) to the `OpenRouterApiClient` that accepts a list of message objects. This method should construct the request payload including the specified model (`qwen/qwen2.5-vl-72b-instruct:free`) and the input messages, and send a POST request to the `/chat/completions` endpoint.",
            "dependencies": [
              2
            ],
            "details": "Define the `completeChat` method signature, taking a list of message objects (define a simple Message class/structure if needed: {role: string, content: string}). Construct the JSON request body using the JSON processing library: `{ \"model\": \"qwen/qwen2.5-vl-72b-instruct:free\", \"messages\": [...] }`. Use the initialized HTTP client to create and send a POST request to `https://openrouter.ai/api/v1/chat/completions` with the JSON body and the API key in the `Authorization: Bearer <API_KEY>` header.",
            "status": "pending",
            "testStrategy": "Use a mocking framework or a test HTTP server to simulate the OpenRouter API endpoint. Send a request via the `completeChat` method and verify that the correct URL, HTTP method (POST), headers (including Authorization), and request body structure are sent."
          },
          {
            "id": 4,
            "title": "Implement Response Handling and Basic Parsing",
            "description": "Modify the `completeChat` method to receive the HTTP response from the API call. Check the HTTP status code. If successful (e.g., 200 OK), parse the JSON response body to extract the generated text from the model's reply.",
            "dependencies": [
              3
            ],
            "details": "After sending the request in `completeChat`, retrieve the response. Check the response status code. If it's a success code, read the response body as a string. Use the JSON processing library to parse the string into a suitable object structure representing the API response (define response classes/structures if needed). Extract the content of the first message in the `choices` array.",
            "status": "pending",
            "testStrategy": "Using a mock HTTP server or mocking framework, simulate a successful API response with a predefined JSON body. Call `completeChat` and verify that the method correctly parses the response and returns the expected text content."
          },
          {
            "id": 5,
            "title": "Integrate API Key Loading and Comprehensive Error Handling",
            "description": "Refine the `OpenRouterApiClient` to load the API key securely using the configured mechanism (from subtask 1). Add robust error handling for various scenarios: network issues, non-2xx HTTP status codes (e.g., 401, 400, 429, 500), and JSON parsing errors. Throw specific exceptions or return error indicators.",
            "dependencies": [
              4
            ],
            "details": "Implement the logic to load the API key from the configured source (environment variable, properties). Ensure the API key is included in the Authorization header for every request. Add try-catch blocks or use the HTTP client's error handling features to catch network exceptions. Check the HTTP status code after receiving the response; if it's an error code, read the error response body (if available) and throw a specific exception (e.g., `OpenRouterApiException`) including the status code and error message. Handle potential exceptions during JSON parsing.",
            "status": "pending",
            "testStrategy": "Write tests that simulate different error conditions using a mock HTTP server or mocking framework: 401 Unauthorized, 400 Bad Request (with error body), 429 Rate Limited, 500 Internal Server Error, and network connection refused. Verify that the client throws appropriate exceptions or handles errors correctly in each case. Also, test that the API key is loaded and used correctly."
          },
          {
            "id": 6,
            "title": "Setup HTTP Client and API Key Configuration",
            "description": "Initialize the chosen HTTP client library (e.g., Apache HttpClient, Spring WebClient, Axios, etc.) and implement logic to load the OpenRouter API key securely from application configuration (e.g., environment variables, properties file).",
            "dependencies": [],
            "details": "Choose an appropriate HTTP client library for the project's technology stack. Configure the client for making POST requests. Implement a configuration loading mechanism to retrieve the API key, ensuring it's not hardcoded. Store the loaded key in a readily accessible place for the client service.",
            "status": "pending",
            "testStrategy": "Verify that the API key is loaded correctly from the configured source and that the HTTP client instance is successfully initialized."
          },
          {
            "id": 7,
            "title": "Create OpenRouterApiClient Class and Basic Request Method",
            "description": "Create the `OpenRouterApiClient` class. Implement a core method (e.g., `chatCompletion`) that accepts message payloads, constructs the basic request body including the specified model (`qwen/qwen2.5-vl-72b-instruct:free`), and prepares to send a POST request to the OpenRouter chat completions endpoint (`https://openrouter.ai/api/v1/chat/completions`) using the configured HTTP client.",
            "dependencies": [
              6
            ],
            "details": "Define the `OpenRouterApiClient` class structure. Create a method signature for `chatCompletion` that takes a list of message objects. Inside the method, create a request object/payload containing the `model` field set to `qwen/qwen2.5-vl-72b-instruct:free` and the `messages` field from the input. Use the initialized HTTP client to prepare the POST request to the target URL.",
            "status": "pending",
            "testStrategy": "Write a unit test to ensure the `chatCompletion` method correctly constructs the request payload with the correct model and messages. Mock the HTTP client to verify the correct URL and method are used."
          },
          {
            "id": 8,
            "title": "Implement API Key Authentication Header",
            "description": "Modify the request sending logic in the `OpenRouterApiClient` to include the loaded API key in the `Authorization` header of the HTTP request, as required by the OpenRouter API.",
            "dependencies": [
              7
            ],
            "details": "Retrieve the API key loaded in subtask 6. Add an `Authorization` header to the HTTP request with the format `Bearer YOUR_API_KEY`. Ensure the header is correctly attached to the POST request before sending.",
            "status": "pending",
            "testStrategy": "Modify the unit test from subtask 7 to verify that the `Authorization` header is correctly added to the mocked HTTP request with the expected format and the loaded API key."
          },
          {
            "id": 9,
            "title": "Send Request and Parse Successful Response",
            "description": "Execute the HTTP POST request using the configured client and handle the successful response (HTTP status 2xx). Parse the JSON response body to extract the generated content from the model.",
            "dependencies": [
              8
            ],
            "details": "Send the prepared HTTP request. Implement logic to check for a successful HTTP status code (e.g., 200 OK). If successful, parse the JSON response body. Navigate the JSON structure (e.g., `choices[0].message.content`) to extract the generated text or relevant output.",
            "status": "pending",
            "testStrategy": "Use integration tests or mock the HTTP client to return a sample successful OpenRouter API response JSON. Verify that the client correctly parses the JSON and extracts the expected content."
          },
          {
            "id": 10,
            "title": "Add Comprehensive Error Handling",
            "description": "Implement robust error handling for potential issues, including HTTP errors (e.g., 4xx, 5xx status codes), API-specific errors returned in the response body, network issues, and JSON parsing errors.",
            "dependencies": [
              9
            ],
            "details": "Add checks for non-2xx HTTP status codes and throw appropriate exceptions. If the API returns error details in the JSON body for certain status codes, parse these details and include them in the exception. Implement catch blocks for network exceptions and JSON parsing exceptions. Define custom exception types for clarity if necessary.",
            "status": "pending",
            "testStrategy": "Write tests (unit or integration with mocked responses) that simulate various error scenarios: non-200 status codes, API error response bodies, network timeouts, and invalid JSON responses. Verify that the client throws the correct exceptions and includes relevant error information."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Roboflow API Client",
        "description": "Develop a client service to interact with the Roboflow API for triggering object analysis on selected models.",
        "details": "Create a service class (e.g., `RoboflowApiClient`). Implement methods to call the Roboflow API endpoints required for triggering analysis on a specific model (e.g., uploading data, requesting analysis). Handle API key and model endpoint configuration. Pseudo-code: `POST https://detect.roboflow.com/...` or similar endpoint based on Roboflow documentation.",
        "testStrategy": "Write integration tests to call the Roboflow API client with mock or actual data and verify successful request sending and response handling.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Setup Database Schema and Connection",
        "description": "Configure database connection and apply the existing `database/schema.sql` for storing metadata and logs.",
        "details": "Configure database properties in `application.properties` or `application.yml` (URL, username, password, driver). Use Spring Data JPA or JDBC to connect. Ensure the schema defined in `database/schema.sql` is applied upon application startup or via a migration tool (e.g., Flyway, Liquibase).",
        "testStrategy": "Verify application connects to the database and that the required tables from `database/schema.sql` exist.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Setup Kafka Logging Integration",
        "description": "Integrate Kafka for logging based on the requirements in `documents/feature-kafka-logging-mongodb.md`.",
        "details": "Add Spring Kafka dependency. Configure Kafka producer properties (bootstrap servers, serializers). Create a service or component responsible for sending log messages to a Kafka topic as described in the referenced document. Ensure compatibility with the MongoDB logging consumer described.",
        "testStrategy": "Implement a simple test producer to send messages to Kafka and verify they are received by a test consumer or visible in the Kafka topic.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Integrated AI Agent: Data Parsing and Analysis",
        "description": "Implement the core logic of the Integrated AI Agent to receive input data and use the OpenRouter API for parsing and semantic analysis.",
        "details": "Create a service (e.g., `IntegratedAiAgentService`). Implement a method that accepts input data (e.g., DTO containing image metadata, text description). Use the `OpenRouterApiClient` (Task 12) to send this data to the Qwen model with a prompt designed for parsing and extracting key information (object type, damage type, environment). Parse the AI's response to extract structured analysis results.",
        "testStrategy": "Write unit/integration tests with various input data formats (valid, invalid, edge cases) and verify the service correctly calls the OpenRouter client and parses the expected structured output.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "completed",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Roboflow Model Routing Logic",
        "description": "Implement the logic to select the most suitable Roboflow model based on the analysis results from the Integrated AI Agent.",
        "details": "Within the `IntegratedAiAgentService` or a dedicated routing service, implement a mapping or rule engine that takes the structured analysis results (e.g., object type='pothole', damage='severe') and selects a corresponding Roboflow model identifier (e.g., 'pothole-detection'). This logic should be designed for extensibility.",
        "testStrategy": "Write unit tests for the routing logic with different analysis results to ensure the correct Roboflow model is selected according to predefined rules.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "completed",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Validation Checking AI Agent",
        "description": "Implement the Validation Checking AI Agent using the OpenRouter API to validate the parsed data and the chosen Roboflow model routing decision.",
        "details": "Create a service (e.g., `ValidationAiAgentService`). Implement methods that take the original input data, the parsed/analyzed data from Task 16, and the chosen Roboflow model from Task 17. Use the `OpenRouterApiClient` (Task 12) with prompts leveraging the Qwen model's OCR/object recognition capabilities to cross-verify the parsed data against the input and validate if the chosen model is appropriate based on the input context. Return a validation status (valid/invalid) and potential error details.",
        "testStrategy": "Write integration tests calling the Validation Agent with valid and invalid scenarios (e.g., data mismatch, inappropriate routing decision) and verify the correct validation status and error messages are returned.",
        "priority": "high",
        "dependencies": [
          12,
          16,
          17
        ],
        "status": "completed",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Transactional Workflow and Error Handling",
        "description": "Implement the core workflow, wrapping the AI processing and validation steps within a single database transaction and handling errors with rollback and logging.",
        "details": "Create a service method that orchestrates calls to `IntegratedAiAgentService` (16, 17) and `ValidationAiAgentService` (18). Annotate this method with Spring's `@Transactional`. If the validation fails (Task 18 returns invalid), throw an exception to trigger transaction rollback. Implement error handling to catch exceptions, log details using the Kafka integration (Task 15), and ensure the transaction is rolled back, maintaining data consistency (Task 14).",
        "testStrategy": "Write integration tests covering success paths, validation failure paths (verify rollback and error logging), and unexpected error paths (verify rollback and error logging).",
        "priority": "high",
        "dependencies": [
          16,
          17,
          18,
          14,
          15
        ],
        "status": "completed",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create API Endpoint for Input Reception",
        "description": "Create a REST API endpoint to receive input data and trigger the integrated AI routing and validation process.",
        "details": "Create a Spring REST Controller. Define an endpoint (e.g., POST `/analyze`) that accepts the input data payload. Inject the service implemented in Task 19 and call its transactional method with the received data. Return an appropriate HTTP response (e.g., 200 OK on success, 400 Bad Request on validation failure, 500 Internal Server Error on system errors).",
        "testStrategy": "Use tools like Postman or write integration tests to call the API endpoint with various inputs (valid, invalid) and verify the system's behavior, responses, and side effects (DB state, logs).",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "completed",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T18:31:39.206Z",
      "updated": "2025-06-29T18:43:55.422Z",
      "description": "Tasks for alert-service context"
    }
  },
  "integration-api": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and API Key Management",
        "description": "Set up the project environment, include necessary libraries/SDKs for VWorld and Address API integration, and implement secure storage and retrieval of API keys.",
        "details": "Initialize the project repository. Choose appropriate libraries or SDKs for interacting with VWorld Map API (likely JavaScript SDK) and the Road Name Address API (standard HTTP client). Implement a secure method for storing and loading API keys (e.g., environment variables on the server-side, or a secure configuration management system) to prevent exposure in client-side code or version control.",
        "testStrategy": "Verify that project dependencies are installed correctly and that API keys can be loaded securely without being exposed in code or logs.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "VWorld Map Initialization and Display",
        "description": "Implement the core functionality to initialize and display the VWorld base map (general, satellite, terrain) within a designated container element on the web page.",
        "details": "Use the VWorld JavaScript API to create a new map instance. Specify the HTML element where the map should be rendered. Set initial map options such as center coordinates (e.g., Korea's center) and zoom level. Allow selection of different base map types as specified in the PRD (general, satellite, terrain).",
        "testStrategy": "Load the application page and verify that the VWorld map is displayed correctly within its container with the specified initial settings.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement VWorld Map Basic Controls",
        "description": "Implement basic map navigation controls such as zooming (in/out), panning (dragging), and potentially rotation if supported and required by the VWorld API.",
        "details": "Utilize the VWorld API's built-in controls or methods to enable user interaction for zooming (e.g., scroll wheel, double click, control buttons) and panning (dragging the map). Ensure smooth and responsive map movement.",
        "testStrategy": "Interact with the map using mouse/touch gestures and verify that zooming and panning function correctly and smoothly.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement VWorld Marker and Overlay Display",
        "description": "Add functionality to place and manage markers or custom overlays on the VWorld map at specified latitude and longitude coordinates.",
        "details": "Use the VWorld API's methods for creating and adding marker objects to the map. Implement functions to set marker position, customize appearance (icon), and potentially add popups or info windows. Include functionality to remove or clear markers from the map.",
        "testStrategy": "Programmatically add markers at known coordinates and verify they appear correctly on the map. Add multiple markers. Remove markers and verify they disappear.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate Road Name Address API Search",
        "description": "Integrate with the Road Name Address API to provide a keyword-based search functionality for addresses.",
        "details": "Implement a backend or frontend function that takes a search keyword (building name, road name, lot number), constructs a request to the Road Name Address API search endpoint (using the API key), handles the HTTP request, and parses the JSON or XML response to extract a list of matching addresses and their details.",
        "testStrategy": "Perform searches for various known addresses (full and partial keywords) and verify that the API returns correct and relevant results. Test edge cases like invalid input or no matching results.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Address API Geocoding and Reverse Geocoding",
        "description": "Implement geocoding (address to coordinate) and reverse geocoding (coordinate to address) functionalities using the Road Name Address API.",
        "details": "Create functions that call the respective geocoding and reverse geocoding endpoints of the Address API. The geocoding function should take an address string and return latitude/longitude coordinates. The reverse geocoding function should take latitude/longitude coordinates and return the corresponding address string. Handle different input formats and parse API responses.",
        "testStrategy": "Geocode several known addresses and verify the returned coordinates are accurate. Reverse geocode coordinates of known locations and verify the returned address strings are correct. Test with coordinates near boundaries or in areas with complex addressing.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Integrate Address Search Results with Map Display",
        "description": "Connect the address search results to the map display. When a user selects an address from the search results, display its location on the VWorld map using a marker.",
        "details": "Modify the logic from Task 5. When a user selects an address from the list of search results, use the geocoding function (Task 6) to obtain the coordinates for that address. Then, use the marker function (Task 4) to place a marker on the map at the obtained coordinates. Optionally, center and zoom the map to focus on the marker location.",
        "testStrategy": "Perform an address search, select a result, and verify that a marker appears at the correct location on the map. Test with multiple search results and selections.",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate Map Click with Address Display (Reverse Geocoding)",
        "description": "Enable users to click on a location on the VWorld map and retrieve/display the corresponding road name address using reverse geocoding.",
        "details": "Add an event listener to the VWorld map instance (Task 2) to detect click events. When a click occurs, retrieve the latitude and longitude coordinates of the clicked point. Call the reverse geocoding function (Task 6) with these coordinates. Display the returned address string to the user, perhaps in a popup/info window on the map or in a dedicated UI element.",
        "testStrategy": "Click on various locations on the map (roads, buildings, open areas) and verify that the correct road name address is retrieved and displayed for each clicked point.",
        "priority": "high",
        "dependencies": [
          2,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop User Interface for Map and Address Functionality",
        "description": "Develop the user interface components necessary for displaying the map, an input field for address search, a list to show search results, and an area/popup to display address information from map clicks.",
        "details": "Design and implement the HTML structure, CSS styling, and JavaScript logic for the UI elements. This includes a container for the VWorld map, an input field for users to type addresses, a dynamic list to display results from Task 5, and a mechanism (e.g., modal, sidebar, map info window) to show address details obtained from Task 7 and Task 8. Connect UI events (button clicks, input changes, list item selection, map clicks) to the backend logic.",
        "testStrategy": "Verify that all UI elements are rendered correctly, are interactive, and respond appropriately to user input and events. Ensure the layout is intuitive and user-friendly.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Error Handling and Performance Optimization",
        "description": "Implement robust error handling for all API calls (VWorld and Address API) and optimize performance to meet the specified requirements (map loading <2s, search response <1s).",
        "details": "Wrap API calls in error handling structures (e.g., try-catch, promise error handlers) to gracefully handle network issues, invalid API keys, rate limits, or API-specific errors. Display informative error messages to the user. Implement performance optimizations such as lazy loading map tiles, debouncing search input, optimizing data processing, and potentially caching API responses where appropriate. Ensure sensitive information like API keys is handled securely.",
        "testStrategy": "Simulate API failures (e.g., block network requests, use invalid keys) and verify that the application handles errors gracefully and displays appropriate messages. Measure map loading time and address search response time under various conditions to ensure they meet the performance targets. Conduct security checks to confirm API keys are not exposed.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T19:32:05.394Z",
      "updated": "2025-06-29T19:32:40.207Z",
      "description": "Tasks for integration-api context"
    }
  },
  "integration-api-final": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Environment Setup and Secure Configuration",
        "description": "Set up the project development environment, including version control, necessary libraries, and secure storage mechanisms for API keys and credentials as required by the technical specifications.",
        "details": "Initialize the project repository. Configure environment variables or a secure vault for storing sensitive information like API keys (VWorld, Naver Maps, data.go.kr, etc.). Ensure necessary SDKs or libraries for API interactions (e.g., HTTP client, JSON/XML parsers, database drivers) are included. Establish a basic project structure.",
        "testStrategy": "Verify environment variables are loaded correctly. Confirm API keys are stored securely and not exposed in code. Run a simple test script to ensure basic library imports and configurations are functional.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Schema Design and Implementation",
        "description": "Design and implement the database schema required to store various types of public data (API responses, parsed data, CSV data) and metadata related to AI datasets and processed information.",
        "details": "Design tables for storing data from data.go.kr, kosis.kr, regional CSVs (e.g., farm data), and potentially metadata about AI datasets and processed results (e.g., AI detection locations). Consider data types (JSONB for flexible API data, specific types for structured data), indexing for performance, and relationships between tables. Implement the schema using chosen database migration tools.",
        "testStrategy": "Verify database connection is successful. Execute schema creation scripts and confirm all tables and columns are created as designed. Perform basic insert/select operations to check data integrity and type handling.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Public Data API Integration (General & KOSIS)",
        "description": "Develop modules to connect to general public data portals like data.go.kr and kosis.kr, handle API authentication (API Key), retrieve data in various formats (JSON, XML), and perform initial parsing.",
        "details": "Implement API client functions for data.go.kr and kosis.kr. Use appropriate libraries for making HTTP requests and parsing JSON/XML responses. Include logic for handling API keys securely (retrieved from secure storage). Implement basic error handling for API call failures (e.g., network errors, authentication errors, rate limits). Store raw or initially parsed data in the database.",
        "testStrategy": "Make successful API calls to data.go.kr and kosis.kr endpoints. Verify data is received in the expected format (JSON/XML). Test parsing logic with sample responses. Confirm error handling mechanisms are triggered for simulated failures (e.g., invalid key, unreachable endpoint).",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Public Data API Integration (Specific & Regional CSV)",
        "description": "Develop modules for integrating with specific public data APIs (bigdata-map.kr, kfss.forest.go.kr, data.go.kr 15057017) and implement a process to download and ingest regional CSV data (15068641, 15034186) into the database.",
        "details": "Implement API client functions for the specific APIs, handling their unique authentication and data formats if different from general APIs. Develop a data ingestion script or module for downloading CSV files from specified URLs. Use a CSV parsing library to read the data and insert it into the appropriate database tables, handling potential data cleaning or transformation during ingestion.",
        "testStrategy": "Successfully call specific APIs and verify data retrieval. Download sample CSV files and run the ingestion process. Check the database to confirm CSV data is correctly parsed and inserted with the correct data types. Test error handling for download failures or parsing errors.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "AI Hub and External Dataset Management",
        "description": "Define and implement the process for downloading, storing, and preparing AI Hub image datasets (Road facilities, Waste, Road surface) and potentially external datasets (gts.ai) for use in AI model training and evaluation.",
        "details": "Develop scripts or tools to download large image datasets from AI Hub and other sources. Design a file storage structure (local filesystem or cloud storage) for these datasets. Implement metadata management in the database (Task 2) to track dataset versions, file paths, annotations, and usage status. Ensure data is organized and potentially pre-processed (e.g., splitting into training/validation/test sets) for AI model pipelines.",
        "testStrategy": "Successfully download sample datasets. Verify files are stored in the correct locations and structure. Check database entries for dataset metadata. Ensure data can be accessed and loaded by a simple script simulating the start of an AI training process.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "VWorld Map API Integration",
        "description": "Integrate the VWorld Map API to display base maps (general, satellite, terrain), implement map controls (zoom, pan, rotate), and enable basic layer management and marker/overlay display.",
        "details": "Use the VWorld JavaScript API or SDK as per their developer documentation. Initialize the map on a web page or application view. Implement controls for user interaction. Develop functions to add and remove markers or simple overlays based on geographic coordinates. Consider handling different map layers provided by VWorld.",
        "testStrategy": "Display a VWorld map centered on a specific location. Test zoom, pan, and rotate controls. Add and remove a static marker at a known coordinate. Toggle visibility of available base map layers.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Naver Map API Integration (Geocoding & Search)",
        "description": "Integrate the Naver Map API to display maps and implement advanced features such as address search, geocoding/reverse geocoding, and POI search.",
        "details": "Use the Naver Maps API (via Naver Cloud Platform). Initialize the map. Implement functions for address-to-coordinate (geocoding) and coordinate-to-address (reverse geocoding) conversions. Develop search functionality for addresses and Points of Interest using the API. Handle API keys and usage limits.",
        "testStrategy": "Display a Naver map. Perform geocoding for a known address and verify the returned coordinates. Perform reverse geocoding for known coordinates and verify the returned address. Search for a local POI and confirm results are displayed.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate AI Detection Results with Map Visualization",
        "description": "Develop the logic to receive AI model detection results (e.g., road damage, illegal waste location) and accurately display these locations as markers or custom overlays on either the VWorld or Naver Maps interface.",
        "details": "Create a data structure to represent AI detection results, including location (latitude, longitude), type of detection, confidence score, and potentially a link to the source image. Implement a function that takes a list of these results and adds corresponding markers or custom icons to the selected map (VWorld or Naver). Ensure markers are clickable to display additional details.",
        "testStrategy": "Simulate receiving AI detection results with various locations. Display these results on both VWorld and Naver maps (if both are used). Verify markers appear at the correct geographic coordinates. Test clicking markers to ensure associated data can be accessed.",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Data Analysis Modules for Regional Statistics",
        "description": "Build modules to query and analyze the stored public data (KOSIS statistics, regional data, etc.) in conjunction with internal project data (e.g., incident reports) to perform regional safety analysis and prepare data for visualization.",
        "details": "Develop database query functions to retrieve relevant data based on geographic area and time period. Implement data processing logic to combine public data (e.g., population density from KOSIS, farm locations from CSV) with internal data (e.g., number of incident reports in an area). Calculate statistics or indicators (e.g., incidents per capita). Prepare aggregated data in a format suitable for display on maps or dashboards.",
        "testStrategy": "Query the database for public and internal data within a specific region. Execute analysis logic and verify calculated statistics are correct based on sample data. Ensure the output data structure is suitable for visualization components.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Cross-cutting Concerns (Error Handling, Performance, Security)",
        "description": "Implement robust error handling, logging, performance optimizations (caching, asynchronous processing), and data consistency checks across all integrated modules.",
        "details": "Implement centralized error handling for all API calls, data parsing, and database operations. Use a logging framework to record errors, warnings, and key events. Apply caching mechanisms for frequently accessed static or slow-changing public data. Use asynchronous processing for API calls or data ingestion tasks to prevent blocking. Implement periodic checks or validation rules to ensure consistency between collected public data and internal data representations.",
        "testStrategy": "Simulate various error conditions (e.g., API downtime, invalid data format, database connection failure) and verify error handling and logging are correct. Measure response times for API calls and data loading with and without caching. Test asynchronous operations to ensure they don't block the main application flow. Implement and run data validation scripts.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T19:41:12.805Z",
      "updated": "2025-06-29T19:42:12.020Z",
      "description": "Tasks for integration-api-final context"
    }
  },
  "refactoring-prd-back-1": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository and Backup",
        "description": "Set up the development environment by backing up the existing projects and creating a new Git branch for the refactoring work.",
        "details": "Ensure both `spring-backend` and `flutter-backend` projects are committed to their respective repositories. Create a new branch, e.g., `feature/backend-integration`, in the `flutter-backend` repository where the integration will take place. This branch will be the working branch for all subsequent tasks. No code changes are made in this step, only repository setup.",
        "testStrategy": "Verify that a new branch has been successfully created in the `flutter-backend` repository and that the current state of both projects is backed up (e.g., via recent commits on main branches).",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Update Gradle Build File",
        "description": "Update the `flutter-backend`'s `build.gradle` file to include all necessary dependencies from `spring-backend`'s `pom.xml` and unify the Java version.",
        "details": "Migrate all `dependencies` from `spring-backend/pom.xml` to `flutter-backend/build.gradle`. Specifically add `spring-boot-starter-websocket`, `spring-boot-starter-cache`, `spring-boot-starter-actuator`, `hibernate-spatial`, JWT (`jjwt-api`, `jjwt-impl`, `jjwt-jackson`), `spring-kafka`, `spring-boot-starter-webflux`, file upload utilities (`commons-fileupload`, `commons-io`), `springdoc-openapi-starter-webmvc-ui`, `org.mapstruct:mapstruct-processor`, and `org.testcontainers` related dependencies. Set the Java version to 21 in `build.gradle`. Apply `maven-compiler-plugin` settings from `spring-backend` (especially `annotationProcessorPaths` for Lombok and MapStruct) to the `build.gradle` file.",
        "testStrategy": "Run `./gradlew build` in the `flutter-backend` project. Verify that the build completes without dependency resolution errors and that the correct Java version is used. Check the generated build artifacts for expected structure.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Integrate Configuration Files",
        "description": "Integrate configuration settings from both projects into a single `application.yml` in `flutter-backend`, prioritizing `spring-backend` settings in case of conflicts.",
        "details": "Copy the content of `spring-backend/src/main/resources/application.yml` to `flutter-backend/src/main/resources/application.yml`. Convert the content of `flutter-backend/src/main/resources/application.properties` to YAML format and merge it into the new `application.yml`. Resolve conflicts for keys like `server.port`, `spring.application.name`, `roboflow` settings by keeping the values from `spring-backend`. Ensure Kafka, OpenRouter, JWT, OAuth2 environment variable placeholders and default values from `spring-backend` are correctly reflected.",
        "testStrategy": "Start the Spring Boot application with the new `application.yml`. Verify that the application starts successfully and loads configurations without errors. Check logs for confirmation of loaded profiles and properties. Manually inspect the merged `application.yml` for correctness and conflict resolution.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Initial Code Migration and Cleanup",
        "description": "Perform initial code migration by removing the old `flutter-backend` demo package and moving the core `spring-backend` package.",
        "details": "Delete the `flutter-backend/src/main/java/com/fix_jb_team/demo/` package and its contents, including `DemoApplication.java` and related test files. Move the entire `spring-backend/src/main/java/com/jeonbuk/report/` directory structure to `flutter-backend/src/main/java/com/jeonbuk/report/`. Ensure `spring-backend/src/main/java/com/jeonbuk/report/JeonbukReportPlatformApplication.java` is present in the new location and set as the main application class in `build.gradle` if necessary. Handle the `RestClientConfig.java` by keeping the one from `spring-backend` (`com.jeonbuk.report.infrastructure.config.RestClientConfig.java`) and removing the one from `flutter-backend` (`com.jeonbuk.report.config.RestClientConfig.java`).",
        "testStrategy": "Verify the file structure in `flutter-backend/src/main/java/` matches the intended merged structure. Attempt a `./gradlew compileJava` to catch basic package/import errors resulting from the move. Ensure `JeonbukReportPlatformApplication.java` is recognized as the main class.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate Domain Models and Update Usage",
        "description": "Integrate and standardize domain models (Entities, DTOs) based on `spring-backend`'s more robust design, resolving conflicts and updating usage.",
        "details": "Adopt `spring-backend`'s domain entities (`User`, `Report`, `Category`, `Status`, `Comment`, `ReportFile`, etc.) as the standard. These models use UUIDs, PostGIS support, and more detailed fields. Modify or replace corresponding entities and DTOs under `flutter-backend/src/main/java/com/jeonbuk/report/domain/` and `dto/` to match `spring-backend`'s models. For example, replace `ReportCategory` entity with `Category` and `ReportStatus` enum with `Status` entity. Update all code references (repositories, services, controllers) to use the standardized models and UUID IDs.",
        "testStrategy": "Perform a `./gradlew compileJava` to ensure all code compiles with the updated domain models. Write or update unit tests for repositories and services interacting with these models to verify data mapping and basic operations (CRUD) work correctly with UUIDs and new fields. Manually inspect key entity and DTO classes to confirm they match the `spring-backend` structure.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate AI Service Logic (Roboflow)",
        "description": "Integrate the business logic from `flutter-backend`'s `RoboflowService` into the `spring-backend`'s AI processing flow.",
        "details": "Keep `spring-backend/src/main/java/com/jeonbuk/report/infrastructure/external/roboflow/RoboflowApiClient.java`. Analyze the business logic in `flutter-backend/src/main/java/com/jeonbuk/report/service/RoboflowService.java`, specifically the Korean class name mapping, problem type mapping (category, priority, department), and mockup response generation. Migrate this logic to `spring-backend`'s `IntegratedAiAgentService.java`, `AiAnalysisService` (if created), or directly within the `RoboflowApiClient` if appropriate, ensuring it integrates seamlessly with the existing AI processing pipeline.",
        "testStrategy": "Write or update unit tests for the integrated AI service logic to verify correct mapping of Roboflow results to internal categories/statuses and proper handling of mockup responses. Perform integration tests simulating a call to the AI analysis endpoint to ensure the end-to-end flow, including the migrated logic, works correctly.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Integrate Controller Logic",
        "description": "Integrate and merge controller logic from `flutter-backend` into the corresponding `spring-backend` controllers.",
        "details": "Merge the functionality of `flutter-backend/src/main/java/com/jeonbuk/report/controller/AIAnalysisController.java` into `spring-backend/src/main/java/com/jeonbuk/report/presentation/controller/AiRoutingController.java`. `AiRoutingController` should be the primary controller for AI-related requests. Merge `flutter-backend/src/main/java/com/jeonbuk/report/controller/ReportController.java` into `spring-backend/src/main/java/com/jeonbuk/report/presentation/controller/ReportController.java`, using the `spring-backend` version as the base and incorporating necessary endpoints or logic from the `flutter-backend` version. Ensure `spring-backend`'s `AlertController` and `UserController` are kept as is. Update package names and imports in the merged controllers.",
        "testStrategy": "Use Swagger UI (`/api/v1/swagger-ui.html`) to verify that all expected API endpoints from both original projects are present and correctly defined in the merged application. Write or update integration tests for key API endpoints (e.g., report creation, AI analysis trigger) to ensure controllers correctly handle requests and delegate to services.",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Refactor and Adjust Core Services",
        "description": "Refactor and adjust core services from `spring-backend` to align with the integrated domain models and logic.",
        "details": "Review and modify `spring-backend` services such as `AiRoutingService`, `AlertService`, `ImageAnalysisService`, `IntegratedAiAgentService`, `UserService`, `ValidationAiAgentService`. Update these services to use the standardized domain entities (UUIDs, new fields) and DTOs. Ensure that the integrated AI logic (from Task 6) and any logic previously handled by `flutter-backend` services (now integrated into controllers or other services) are correctly invoked and processed within the relevant `spring-backend` services. Update package names and imports as needed.",
        "testStrategy": "Write or update unit tests for the refactored services to verify their core business logic functions correctly with the new domain models and integrated components. Focus on testing interactions between services and repositories, and interactions between different services.",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Migrate and Update Test Code",
        "description": "Migrate all test code from `spring-backend` to `flutter-backend` and update tests to work with the merged codebase.",
        "details": "Delete `flutter-backend/src/test/java/com/fix_jb_team/demo/DemoApplicationTests.java`. Move all test code from `spring-backend/src/test/java/com/jeonbuk/report/` to `flutter-backend/src/test/java/com/jeonbuk/report/`. Update package names and imports in the migrated test files. Modify test classes and methods as necessary to reflect changes in class names, package structure, method signatures, and the use of standardized domain models (UUIDs). Ensure test configurations (e.g., Testcontainers setup) are correctly applied in the `flutter-backend` test environment.",
        "testStrategy": "Attempt to run all migrated tests using `./gradlew test`. Identify and fix compilation errors and test failures resulting from the code integration. Ensure test dependencies are correctly configured in `build.gradle` (Task 2).",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Build, Run Tests, and Verify Functionality",
        "description": "Perform a full build, run all tests, and conduct comprehensive functional and performance verification of the integrated backend service.",
        "details": "Run `./gradlew clean build` to ensure the entire project compiles and packages correctly. Execute all unit and integration tests using `./gradlew test`. Start the application and perform manual functional testing covering all key business flows: report creation/management, user authentication (standard, OAuth), AI analysis (object detection, OCR), Kafka messaging, notifications, and PostGIS location search. Use Swagger UI (`/api/v1/swagger-ui.html`) to test API endpoints. Monitor application logs for errors. Conduct basic performance checks on critical API endpoints.",
        "testStrategy": "Verify that `./gradlew build` and `./gradlew test` complete successfully with all tests passing. Confirm all features listed in the 'Verification' section (5.0) of the PRD function as expected through manual and automated tests. Check application logs for any runtime errors or warnings. Perform load testing on key endpoints if performance targets are specified (though not detailed in this PRD, basic checks are prudent).",
        "priority": "high",
        "dependencies": [
          2,
          3,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T19:55:08.343Z",
      "updated": "2025-06-29T19:55:52.428Z",
      "description": "Tasks for refactoring-prd-back-1 context"
    }
  }
}