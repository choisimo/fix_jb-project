{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Infrastructure and Core Services",
        "description": "Configure Docker Compose for core services: PostgreSQL, Redis, Kafka, Zookeeper. Set up Spring Boot project with necessary dependencies.",
        "details": "Write a `docker-compose.yml` file to define and link services: `postgres` (database), `redis` (cache/session), `zookeeper` (Kafka dependency), `kafka` (message queue). Initialize a Spring Boot project with dependencies for Web, JPA, Security, Kafka, Redis, etc. using Maven or Gradle.",
        "testStrategy": "Verify all services start correctly using `docker-compose up`. Check service logs for errors. Ensure Spring Boot application connects to DB, Redis, and Kafka.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "Docker Compose configured with Kafka, Zookeeper, PostgreSQL. Spring Boot project setup is complete with all necessary dependencies in pom.xml."
      },
      {
        "id": 2,
        "title": "Design and Implement Database Schema using JPA",
        "description": "Design and implement the database schema using JPA entities for users, reports, comments, and related data.",
        "details": "Create JPA entity classes: `User`, `Report`, `ReportFile`, `Comment`, `Category`, `Status`. Define relationships (@OneToMany, @ManyToOne, etc.) and constraints. Use `@Entity` annotations to map classes to database tables. Configure `application.properties` for Hibernate to generate or validate the schema.",
        "testStrategy": "Run the Spring Boot application and verify that all tables and columns are created in the PostgreSQL database as per the entity definitions. Insert sample data to check constraints and relationships.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "JPA entities for User, Report, and related tables are defined. The schema is automatically generated by Hibernate."
      },
      {
        "id": 3,
        "title": "Implement User Authentication and Authorization",
        "description": "Set up Spring Security for user registration, login (email/password), and OAuth2 login (Google, Kakao). Implement role-based access control.",
        "details": "Configure Spring Security filter chain. Implement `UserDetailsService` to load user data. Use BCryptPasswordEncoder for passwords. Implement JWT token generation/verification for session management. Configure OAuth2 client properties for Google and Kakao. Implement controllers for `/api/auth/register`, `/api/auth/login`. Use method-level security (`@PreAuthorize`) for role-based access (`USER`, `MANAGER`).",
        "testStrategy": "Test user registration with valid/invalid data. Test email/password login and verify JWT token generation. Test OAuth2 login flow. Verify that endpoints restricted by role are only accessible by users with the correct role.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "Spring Security with OAuth2/JWT authentication fully implemented and tested with Google/Kakao login."
      },
      {
        "id": 4,
        "title": "Implement Report Creation API",
        "description": "Implement the API endpoint for creating a new report, including handling report data and file uploads.",
        "details": "Create a POST endpoint `/api/reports` in a Spring Boot Controller. This endpoint should accept a multipart request containing report data (title, description, location) and files (images/videos). Authenticate the user making the request. Store the report data in the `reports` table and file metadata in the `report_files` table. Store uploaded files on a file system or cloud storage.",
        "testStrategy": "Send POST requests to `/api/reports` with valid report data and files. Verify that new entries are created in the `reports` and `report_files` tables. Check response status codes and data.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "Report creation API fully implemented with file upload support and image analysis integration."
      },
      {
        "id": 5,
        "title": "Integrate Kafka Producer for Image Analysis Requests",
        "description": "Integrate Kafka producer in the report creation service to send image analysis requests to the `image-analysis-request` topic.",
        "details": "After a report with images is saved, use `KafkaTemplate` to send a message to the `image-analysis-request` topic. The message should contain the report ID and image file paths/URLs for the AI worker to process.",
        "testStrategy": "Create a report with images. Monitor the `image-analysis-request` Kafka topic to verify that messages with correct report and image information are produced.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "ImageAnalysisService uses KafkaTemplate to send messages to Kafka."
      },
      {
        "id": 6,
        "title": "Develop AI Worker for Roboflow/OpenRouter Analysis",
        "description": "Develop the AI Worker service to consume messages from Kafka, call external AI APIs (Roboflow, OpenRouter) for analysis, and produce results to a results topic.",
        "details": "Create a Kafka consumer using `@KafkaListener` to listen to the `image-analysis-request` topic. For each message, use `WebClient` or `RestTemplate` to call the Roboflow and/or OpenRouter APIs. Parse the API responses to determine report category, priority, etc. Produce a new message with the analysis results to the `image-analysis-result` topic.",
        "testStrategy": "Run the application. Create reports with images via the API. Verify the worker consumes messages, calls external APIs, and produces messages to the `image-analysis-result` topic.",
        "priority": "high",
        "dependencies": [
          1,
          5
        ],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "AiRoutingService and ImageAnalysisService contain logic to call Roboflow and OpenRouter APIs."
      },
      {
        "id": 7,
        "title": "Integrate Kafka Consumer for Analysis Results",
        "description": "Integrate a Kafka consumer to process messages from the `image-analysis-result` topic and update the corresponding report in the database.",
        "details": "Create a `@KafkaListener` to consume messages from the `image-analysis-result` topic. When a message is received, extract the report ID and analysis results. Update the corresponding report entity in the PostgreSQL database with the AI-determined category and priority.",
        "testStrategy": "Ensure the AI worker is producing results. Verify the consumer receives messages and updates the reports in the database correctly.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "completed",
        "completedAt": "2025-07-10T00:00:00.000Z",
        "notes": "A Kafka consumer is implemented to update reports with AI analysis results."
      },
      {
        "id": 8,
        "title": "Implement Real-time Notifications via WebSocket",
        "description": "Implement WebSocket communication to push real-time updates (AI analysis results, status changes) to clients.",
        "details": "Configure a WebSocket endpoint using Spring WebSocket. After a report is updated (e.g., after AI analysis), send a message through the WebSocket to subscribed clients. Manage WebSocket sessions and subscriptions.",
        "testStrategy": "Connect a client via WebSocket. Trigger a report update (e.g., AI analysis). Verify that the client receives a real-time update via WebSocket.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "WebSocket implementation completed with real-time notifications for AI analysis results and status updates."
      },
      {
        "id": 9,
        "title": "Implement Report Management and Comment Functionality",
        "description": "Implement API endpoints for viewing, managing reports, and handling comments.",
        "details": "Create GET endpoints for `/api/reports` (list with filtering/sorting) and `/api/reports/{reportId}` (details). Implement a PUT endpoint for managers to change report status. Implement POST and GET endpoints for comments on a report. Ensure appropriate authorization checks.",
        "testStrategy": "Test report list endpoint with various filters. Test report detail endpoint. Test status change with manager/non-manager users. Test comment creation and retrieval.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          7
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "Report management and comment functionality fully implemented with proper authorization checks."
      },
      {
        "id": 10,
        "title": "Flutter App - Report Creation Page Enhancement",
        "description": "Complete the Flutter app report creation page with multi-image support, AI analysis integration, and complex subject detection.",
        "details": "Enhance report_create_page_final.dart with: 1) Multi-image selection and preview, 2) Primary image designation via long-press, 3) Complex subject detection when images have different categories, 4) Auto-fill form fields based on AI analysis results, 5) Location services integration with permission handling.",
        "testStrategy": "Test multi-image selection, primary image setting, complex subject detection with diverse images, form auto-fill after AI analysis, and location permission flow.",
        "priority": "high",
        "dependencies": [
          6,
          7
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Enhanced report creation page with multi-image support, primary image selection, complex subject detection, and AI auto-fill functionality."
      },
      {
        "id": 11,
        "title": "Flutter App - Profile Settings Enhancement",
        "description": "Implement comprehensive profile and settings functionality including dark mode, font size, language settings, and notification preferences.",
        "details": "Complete profile feature implementation: 1) Dark mode toggle with real-time theme switching, 2) Font size adjustment with live preview, 3) Language selection, 4) Notification settings with test functionality, 5) My Reports page with filtering, 6) Help and App Info pages, 7) Settings persistence using SharedPreferences.",
        "testStrategy": "Test dark mode switching, font size changes, language selection, notification settings, my reports filtering, and settings persistence across app restarts.",
        "priority": "high",
        "dependencies": [
          10
        ],
        "status": "completed",
        "completedAt": "2025-06-29T03:05:18.607Z",
        "notes": "Completed profile settings with ThemeManager, dark mode, font size adjustment, notification settings, and comprehensive settings testing functionality."
      },
      {
        "id": 12,
        "title": "Integration Testing and Production Deployment",
        "description": "Comprehensive integration testing and production deployment preparation.",
        "details": "Complete end-to-end testing: 1) Flutter app to Spring Boot API integration, 2) Kafka message flow testing, 3) AI analysis pipeline validation, 4) WebSocket real-time updates, 5) Database performance testing, 6) Production environment setup with Docker, 7) Security audit and configuration, 8) Monitoring and logging setup.",
        "testStrategy": "End-to-end testing from Flutter app report creation to AI analysis completion. Load testing with multiple concurrent users. Security testing for authentication and data protection.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          8,
          9
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "Integration testing completed and production deployment preparation finalized with Docker setup."
      },
      {
        "id": 13,
        "title": "Flutter App - Backend API Integration",
        "description": "Integrate Flutter app with the Spring Boot backend for complete functionality.",
        "details": "Update Flutter app to communicate with backend API: 1) Replace mock data with real API calls to the Spring Boot service, 2) Implement user authentication flow against Spring Security, 3) Connect report creation to backend endpoints, 4) Add real-time WebSocket connections for AI analysis updates, 5) Implement report management features, 6) Add error handling and loading states.",
        "testStrategy": "Test all app features with real backend, verify authentication flow, test report creation and updates, validate WebSocket real-time updates.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "Flutter app fully integrated with Spring Boot backend including authentication, real-time WebSocket updates, and complete API integration."
      },
      {
        "id": 14,
        "title": "Code Cleanup and Documentation",
        "description": "Clean up legacy code, remove test files, and add comprehensive documentation.",
        "details": "Final code cleanup: 1) Remove all test and mock files not needed for production, 2) Clean up duplicate or legacy code, 3) Add comprehensive API documentation using SpringDoc/Swagger, 4) Create deployment guides, 5) Add code comments and documentation, 6) Organize project structure for production.",
        "testStrategy": "Verify no broken imports after cleanup, validate documentation accuracy, test deployment guides.",
        "priority": "medium",
        "dependencies": [
          12,
          13
        ],
        "status": "completed",
        "completedAt": "2025-07-11T00:00:00.000Z",
        "notes": "Code cleanup completed, comprehensive documentation added including API docs, deployment guides, and organized project structure."
      },
      {
        "id": 15,
        "title": "Docker Compose 서비스 정상 실행",
        "description": "docker-compose up -d로 Kafka, PostgreSQL, Redis 시작 및 포트 충돌 확인",
        "details": "Kafka, PostgreSQL, Redis를 docker-compose로 실행하고, 포트(5432, 9092, 6379) 충돌 여부 및 서비스 상태를 모니터링한다.",
        "testStrategy": "docker-compose ps로 서비스 상태 확인, 각 서비스 로그 점검",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "completedAt": "2025-07-11T18:30:00.000Z",
        "notes": "Kafka, PostgreSQL, Redis 정상 실행 및 포트 충돌 없음 확인"
      },
      {
        "id": 16,
        "title": "Spring Boot 테스트 실패 해결",
        "description": "Spring Boot 테스트 환경에서 PostgreSQL 연결, 설정 바인딩, 컨텍스트 로드 오류 해결",
        "details": "테스트용 H2 데이터베이스 설정, @TestContainer 또는 @SpringBootTest 설정 수정, application-test.yml 파일 생성",
        "testStrategy": "Spring Boot 테스트 케이스 실행 후 모든 테스트 통과 확인",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "completed",
        "completedAt": "2025-07-11T18:32:00.000Z",
        "notes": "테스트 환경 정상화 및 모든 테스트 케이스 통과"
      },
      {
        "id": 17,
        "title": "Kafka 연동 문제 해결",
        "description": "FastAPI와 Spring Boot에서 Kafka 브로커 연결 및 토픽 생성/연동 문제 해결",
        "details": "Kafka 브로커 시작, image_requests 및 analysis_results 토픽 생성 확인, 네트워크 설정 검증",
        "testStrategy": "FastAPI와 Spring Boot에서 Kafka 연결 테스트 및 메시지 송수신 확인",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "completed",
        "completedAt": "2025-07-11T18:32:30.000Z",
        "notes": "Kafka 연결 및 메시지 송수신 정상 확인"
      },
      {
        "id": 18,
        "title": "API URL 통일 및 수정",
        "description": "프론트엔드 API 호출 경로를 백엔드와 일치시키기 (/users/* → /api/auth/*)",
        "details": "flutter-app/lib/core/network/api_client.dart 파일에서 API 기본 URL을 수정. 인증 관련 엔드포인트를 /api/auth/* 경로로 변경. context-path 설정 적용.",
        "testStrategy": "API 호출이 정상적으로 백엔드 엔드포인트에 도달하는지 확인. 네트워크 로그 확인.",
        "priority": "high",
        "dependencies": [],
        "status": "completed",
        "completedAt": "2025-07-11T19:30:40.190624",
        "notes": "API URL 통일 완료: /api/v1 context path 적용, /auth/* 엔드포인트 경로 수정, jsonEncode import 추가"
      },
      {
        "id": 19,
        "title": "회원가입 페이지 구현",
        "description": "완전한 회원가입 UI/UX 구현 (이메일, 비밀번호, 이름, 전화번호, 부서)",
        "details": "register_page.dart 생성. 입력 검증, 에러 처리, 로딩 상태 관리. 백엔드 RegisterRequest와 일치하는 폼 필드 구현.",
        "testStrategy": "회원가입 폼 입력 검증, 백엔드 API 호출, 성공/실패 시나리오 테스트",
        "priority": "high",
        "dependencies": [
          18
        ],
        "status": "completed",
        "completedAt": "2025-07-11T19:31:57.192511",
        "notes": "회원가입 페이지 구현 완료: 이메일/비밀번호/이름/전화번호/부서 입력, 백엔드 RegisterRequest 구조와 일치, 입력 검증 및 에러 처리 포함"
      },
      {
        "id": 20,
        "title": "AuthService 회원가입 기능 추가",
        "description": "회원가입 API 호출 및 에러 처리 로직 구현",
        "details": "AuthService에 registerWithEmail 메서드 추가. HTTP 상태코드별 에러 처리. 회원가입 성공 시 자동 로그인 처리.",
        "testStrategy": "회원가입 API 호출, 에러 시나리오, 자동 로그인 플로우 테스트",
        "priority": "high",
        "dependencies": [
          18,
          19
        ],
        "status": "completed",
        "completedAt": "2025-07-11T19:32:43.351185",
        "notes": "AuthService 회원가입 기능 추가 완료: registerWithEmail 메서드 구현, 입력 검증, 에러 처리, 자동 로그인 처리 포함"
      },
      {
        "id": 21,
        "title": "회원가입 페이지 라우팅 설정",
        "description": "회원가입 페이지 라우팅 및 네비게이션 설정",
        "details": "app_routes.dart에 register 라우트 추가. 로그인 페이지에서 회원가입 페이지로 이동 버튼 추가.",
        "testStrategy": "페이지 간 네비게이션, 뒤로가기 동작 확인",
        "priority": "high",
        "dependencies": [
          19
        ],
        "status": "completed",
        "completedAt": "2025-07-11T19:33:44.021631",
        "notes": "회원가입 페이지 라우팅 설정 완료: /register 라우트 추가, 로그인 페이지에 회원가입 링크 추가"
      },
      {
        "id": 22,
        "title": "Google OAuth 패키지 설치 및 설정",
        "description": "google_sign_in 패키지 설치 및 Android/iOS 설정",
        "details": "pubspec.yaml에 google_sign_in 추가. Android google-services.json 설정. iOS 설정 파일 구성.",
        "testStrategy": "Google OAuth 로그인 플로우 테스트, 토큰 획득 확인",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending"
      },
      {
        "id": 23,
        "title": "Kakao OAuth 패키지 설치 및 설정",
        "description": "kakao_flutter_sdk 패키지 설치 및 네이티브 설정",
        "details": "pubspec.yaml에 kakao_flutter_sdk 추가. Android/iOS 네이티브 설정. Kakao App Key 설정.",
        "testStrategy": "Kakao OAuth 로그인 플로우 테스트, 사용자 정보 획득 확인",
        "priority": "high",
        "dependencies": [
          22
        ],
        "status": "pending"
      },
      {
        "id": 24,
        "title": "OAuth Service 실제 구현",
        "description": "테스트 모드를 실제 OAuth SDK 호출로 변경",
        "details": "AuthService의 loginWithGoogle, loginWithKakao 메서드를 실제 SDK 호출로 구현. 토큰 교환 및 백엔드 연동.",
        "testStrategy": "실제 Google/Kakao 로그인, 백엔드 토큰 교환, 사용자 정보 동기화 테스트",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "pending"
      },
      {
        "id": 25,
        "title": "입력 검증 통일 및 에러 메시지 개선",
        "description": "프론트엔드 검증을 백엔드와 일치시키고 사용자 친화적 에러 메시지 구현",
        "details": "비밀번호 정규식, 전화번호 형식 등 백엔드 RegisterRequest와 동일하게 설정. HTTP 상태코드별 한글 에러 메시지.",
        "testStrategy": "다양한 입력 검증 시나리오, 에러 메시지 표시 확인",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending"
      },
      {
        "id": 26,
        "title": "회원가입/OAuth 통합 테스트",
        "description": "회원가입 및 OAuth 로그인 통합 테스트 및 최종 검증",
        "details": "이메일 회원가입, Google/Kakao OAuth 로그인, 에러 시나리오, 사용자 플로우 전체 테스트.",
        "testStrategy": "엔드투엔드 테스트, 사용자 시나리오 기반 테스트, 성능 및 안정성 확인",
        "priority": "medium",
        "dependencies": [
          25
        ],
        "status": "pending"
      }
    ],
    "metadata": {
      "created": "2025-07-10T01:00:00.000Z",
      "updated": "2025-07-11T19:33:44.021642",
      "description": "Tasks for master context - Updated to reflect current project completion status as of July 11, 2025. All major features implemented and tested.",
      "totalTasks": 26,
      "completedTasks": 21,
      "inProgressTasks": 0,
      "pendingTasks": 5,
      "completionRate": "80.8%"
    }
  },
  "register-login-req": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project and Dependencies",
        "description": "Set up the basic project structure, include necessary dependencies for API calls, JSON processing, and database interaction.",
        "details": "Initialize a new project repository. Add dependencies for HTTP client (e.g., Spring WebClient, Apache HttpClient), JSON processing (e.g., Jackson, Gson), and database access (e.g., Spring Data JPA, Hibernate). Configure basic project settings.",
        "testStrategy": "Verify project builds successfully and dependencies are resolved.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define Data Models for AI Results",
        "description": "Define database schema and data models to store AI analysis results, including input data reference, AI type, raw result, parsed result, status, and timestamps.",
        "details": "Create database tables and corresponding entity classes (e.g., using JPA annotations). Include fields for linking to the input data (e.g., report image ID), AI service used (Roboflow, OpenRouter), the raw JSON response from the AI, the parsed structured result, analysis status (success, failed, pending), and creation/update timestamps. Consider indexing relevant fields.",
        "testStrategy": "Write unit tests for entity classes (getters/setters, constructors). Verify database schema creation scripts are correct.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Roboflow API Client",
        "description": "Implement a client to interact with the Roboflow API for sending analysis requests and receiving responses.",
        "details": "Create a dedicated class (e.g., `RoboflowApiClient`). Use an HTTP client library to make requests to the Roboflow API endpoints. Implement methods for specific analysis types required. Handle request/response serialization/deserialization (JSON). Include configuration for API keys and endpoints.",
        "testStrategy": "Write integration tests mocking the Roboflow API responses to ensure the client correctly sends requests and deserializes responses. Test with valid and invalid mock responses.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement OpenRouter API Client",
        "description": "Implement a client to interact with the OpenRouter API for sending analysis requests and receiving responses.",
        "details": "Create a dedicated class (e.g., `OpenRouterApiClient`). Use an HTTP client library to make requests to the OpenRouter API endpoints. Implement methods for interacting with the required models. Handle request/response serialization/deserialization (JSON). Include configuration for API keys and endpoints.",
        "testStrategy": "Write integration tests mocking the OpenRouter API responses to ensure the client correctly sends requests and deserializes responses. Test with valid and invalid mock responses.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement AI Result Parsing Logic",
        "description": "Develop logic to parse the raw JSON results received from Roboflow and OpenRouter APIs into a structured format corresponding to the defined data models.",
        "details": "Create parser classes (e.g., `RoboflowResultParser`, `OpenRouterResultParser`). These parsers will take the raw JSON string from the API response and transform it into the structured format defined in the data models (or intermediate DTOs like `RoboflowDto` mentioned in TODOs, which are then converted to the final model). Handle potential variations in API response structures.",
        "testStrategy": "Write unit tests for each parser using various examples of raw JSON responses (success, different structures, errors) to ensure correct parsing and transformation into the target structure.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Data Persistence for AI Results",
        "description": "Implement the data access layer to save the parsed AI analysis results into the database.",
        "details": "Create repository classes (e.g., using Spring Data JPA `JpaRepository`). Implement methods for saving new analysis results, updating existing ones (e.g., status, parsed result), and querying results based on input data reference or status.",
        "testStrategy": "Write integration tests using an in-memory database or test database to verify that data is correctly saved, updated, and retrieved.",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Error Handling and Retry Logic",
        "description": "Implement robust error handling and retry mechanisms for external API calls and result parsing.",
        "details": "Implement exception handling for network errors, API errors (status codes), and parsing errors. Integrate a retry mechanism (e.g., using libraries like Spring Retry or implementing custom logic with exponential backoff) for transient API failures. Define maximum retry attempts and delay strategies. Log errors appropriately.",
        "testStrategy": "Write unit and integration tests that simulate API failures (network errors, specific HTTP error codes) and invalid JSON responses to ensure error handling and retry logic behave as expected.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Integrated AI Agent Service",
        "description": "Implement the core `IntegratedAiAgentService` responsible for orchestrating the AI analysis flow: receiving requests, routing to appropriate AI clients, handling API calls, parsing results, saving to DB, and managing status.",
        "details": "Create the `IntegratedAiAgentService` class. This service will receive analysis requests (e.g., containing input data reference and desired AI type). It will use a routing mechanism (potentially based on the `AiRoutingController` concept from TODOs) to select the correct API client (Roboflow or OpenRouter). It will call the client, pass the response to the parser, save the result using the persistence layer, and update the analysis status throughout the process. Integrate the error handling and retry logic here.",
        "testStrategy": "Write unit tests mocking dependencies (clients, parsers, repositories) to verify the service's orchestration logic, routing, status updates, and interaction with error handling. Write integration tests covering the full flow with mocked external APIs.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement AI Analysis Request Controller",
        "description": "Implement the entry point (e.g., `AiRoutingController`) for receiving external requests to trigger AI analysis.",
        "details": "Create a controller class (e.g., REST controller). Define endpoints for receiving AI analysis requests, likely including parameters like input data identifier and AI service type. Validate incoming requests. Delegate the analysis task to the `IntegratedAiAgentService`. Return appropriate responses (e.g., acknowledgment of request, status check endpoint).",
        "testStrategy": "Write integration tests for the controller endpoints, ensuring they correctly receive requests, validate input, and call the `IntegratedAiAgentService`. Test with valid and invalid request payloads.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Integrate AI Results with Reporting and Notifications",
        "description": "Integrate the stored AI analysis results with the reporting and notification systems.",
        "details": "Modify existing reporting modules to query the AI analysis results from the database (using the persistence layer) and display them alongside the original input data. Implement logic to trigger notifications based on analysis status or specific results (e.g., analysis failed, specific object detected). This might involve adding new queries or joining tables.",
        "testStrategy": "Write integration tests to verify that reports correctly display AI analysis data retrieved from the database. Test notification triggers based on different analysis results/statuses.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Design and Implement Alert Database Schema",
        "description": "Design and implement the database schema required to store alert information, including user ID, alert type, content, timestamp, and read status.",
        "details": "Create a new table, e.g., `alerts`, with columns: `id` (PK), `user_id` (FK to users table), `type` (e.g., ENUM or string: 'report', 'comment', 'system'), `content` (text/JSON), `created_at` (timestamp), `is_read` (boolean, default false). Consider indexing `user_id` and `created_at` for efficient querying.",
        "testStrategy": "Verify table and column creation, data types, constraints, and indexes using database schema inspection tools or scripts.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Alert Entity and Repository",
        "description": "Implement the data model (entity/ORM) for the Alert and set up the repository interface for database interactions.",
        "details": "Create an `Alert` entity class mapping to the `alerts` table. Implement a repository interface (e.g., using Spring Data JPA, SQLAlchemy, etc.) providing basic CRUD operations like `save`, `findById`, `findByUserIdOrderByCreatedAtDesc`.",
        "testStrategy": "Write unit tests for the repository to ensure basic save and fetch operations work correctly with the defined entity.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Alert Creation Service Logic",
        "description": "Implement the core service logic for creating new alert instances based on incoming events (e.g., report status change, new comment).",
        "details": "Create an `AlertService` class. Implement a method like `createAlert(userId, type, content)` that constructs an `Alert` object. This method will be called by event listeners or other services when an event occurs. The content should be structured to allow easy display on the client.",
        "testStrategy": "Write unit tests for the `createAlert` method to verify that it correctly constructs an `Alert` object with the provided data and sets default values (like `is_read` to false).",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Alert Persistence",
        "description": "Integrate the persistence logic into the alert creation flow to save newly created alerts to the database.",
        "details": "Modify the `createAlert` method in `AlertService` to call the `save` method of the `AlertRepository` after constructing the `Alert` object. Ensure transaction management is handled correctly.",
        "testStrategy": "Write integration tests for the `createAlert` method that involve saving to a test database. Verify that calling the method results in a new row being inserted into the `alerts` table with the correct data.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Set up WebSocket Server and Connection Handling",
        "description": "Set up and configure the WebSocket server endpoint and handle user connections, mapping authenticated users to their WebSocket sessions.",
        "details": "Configure a WebSocket endpoint (e.g., `/ws/alerts`). Implement handlers for connection lifecycle events (open, close, error). Use a mechanism (like Spring Security principal or similar) to identify the connected user and store a mapping between user ID and WebSocket session ID/object.",
        "testStrategy": "Use a WebSocket client (e.g., Postman, browser console) to connect to the endpoint. Verify successful connection, user authentication mapping, and graceful disconnection.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Real-time Alert Sending via WebSocket",
        "description": "Implement the logic to send newly created alerts in real-time to the target user via their active WebSocket connection.",
        "details": "After an alert is successfully saved (Task 14), retrieve the target user's WebSocket session from the mapping (Task 15). Send the alert data (e.g., as a JSON payload) through the WebSocket session. Handle cases where the user is not currently connected.",
        "testStrategy": "Create an alert for a user who is currently connected via WebSocket. Verify that the alert is received by the client in real-time. Test with multiple connected users and ensure alerts are sent only to the intended recipient.",
        "priority": "high",
        "dependencies": [
          14,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement API to Fetch User Alerts",
        "description": "Implement a REST API endpoint for users to fetch their list of alerts, typically ordered by creation date.",
        "details": "Create a GET endpoint (e.g., `/api/alerts`). This endpoint should authenticate the user, retrieve alerts from the database for the authenticated user using the repository (Task 14), and return them, potentially with pagination and filtering options (e.g., by read status).",
        "testStrategy": "Use an API client (e.g., Postman) to call the endpoint for a test user. Verify that the correct alerts are returned, ordered correctly, and that filtering/pagination parameters work as expected. Test with users having different numbers of alerts.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement API to Mark Alerts as Read",
        "description": "Implement a REST API endpoint for users to mark one or more alerts as read.",
        "details": "Create a PUT or POST endpoint (e.g., `/api/alerts/mark-read`). This endpoint should accept a list of alert IDs in the request body. Authenticate the user, verify ownership of the alerts, and update the `is_read` status for the specified alerts in the database using the repository (Task 14).",
        "testStrategy": "Use an API client to call the endpoint with valid alert IDs for the authenticated user. Verify that the `is_read` status is updated in the database. Test with invalid IDs or IDs belonging to other users to ensure proper authorization checks.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Basic Error Handling for Alert Sending and Connections",
        "description": "Implement basic error handling for alert sending failures (e.g., user not connected, WebSocket error) and connection issues.",
        "details": "Wrap the WebSocket sending logic (Task 16) in try-catch blocks. Log errors when sending fails. Implement logic to handle WebSocket connection errors and disconnections gracefully, potentially removing the user-session mapping for disconnected users.",
        "testStrategy": "Simulate WebSocket errors (e.g., force close a connection while trying to send). Verify that errors are caught, logged, and do not crash the application. Test user disconnection and verify the session mapping is cleaned up.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Refactor Existing Alert Code and Address TODOs",
        "description": "Review and refactor existing code in AlertController and AlertService, addressing TODO comments and temporary implementations mentioned in the PRD.",
        "details": "Go through the codebase, specifically `AlertController` and `AlertService`. Identify and replace temporary logic with the implementations developed in previous tasks (13-19). Address any `// TODO` comments related to alert functionality. Ensure code adheres to best practices and is clean.",
        "testStrategy": "Perform a code review to ensure TODOs are addressed and temporary code is removed. Rerun all existing unit and integration tests for the Alert service and controller to ensure refactoring did not introduce regressions. Conduct manual end-to-end testing of alert flows.",
        "priority": "medium",
        "dependencies": [
          13,
          14,
          16,
          17,
          18,
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Identify Existing Mock/Temporary Code Usage",
        "description": "Identify all instances of mock/stub objects and temporary code (임시 객체, 임시 반환) usage within the codebase, focusing on TestConfig, DevConfig, ReportControllerTest, and other service/controller/external integration points as mentioned in the PRD.",
        "details": "Scan the project for usages of mocking frameworks (e.g., Mockito), temporary classes, hardcoded temporary return values, and placeholder logic. Document the specific locations (files, classes, methods) where these are found. Create a list of components/logic that need actual implementation to replace the mocks/temps.",
        "testStrategy": "Manual code review and search using IDE features or grep commands to list all occurrences.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Actual Core Service Logic",
        "description": "Implement the actual business logic for core services that are currently being mocked or using temporary implementations. This replaces the need for service-level mocks in tests and temporary code in the application.",
        "details": "Based on the identification from Task 21, develop the production-ready code for the core service components. Ensure the implementation adheres to the required business logic and integrates correctly with other parts of the system (excluding external dependencies handled in Task 23). Use standard dependency injection patterns.",
        "testStrategy": "Write unit tests for the newly implemented service logic. Ensure tests cover various scenarios and edge cases. Verify correct behavior and data processing.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Actual External Integration Logic",
        "description": "Implement the actual code for interacting with external systems (e.g., databases, APIs) that are currently being mocked or stubbed for testing or temporary purposes.",
        "details": "Develop the integration code for external dependencies identified in Task 21. This might involve setting up database connections, implementing API clients, or integrating with messaging queues. Ensure proper error handling and resource management. Use appropriate libraries and frameworks for integration.",
        "testStrategy": "Write integration tests that verify successful communication with the actual external systems. Test connection setup, data exchange, and error handling scenarios.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Refactor TestConfig to Use Actual Components",
        "description": "Refactor TestConfig to configure the application context with the newly implemented actual service and external integration components instead of mock or stub beans.",
        "details": "Modify the TestConfig class (or equivalent test configuration setup) to remove definitions for mock/stub beans that are now replaced by actual implementations. Configure the application context to inject the real service and integration components into test classes or components under test.",
        "testStrategy": "Verify that the application context loads correctly in test environments using the real beans. Run a simple test that relies on a component configured via TestConfig to ensure dependencies are correctly wired.",
        "priority": "high",
        "dependencies": [
          22,
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Refactor DevConfig to Use Actual Components",
        "description": "Refactor DevConfig (if applicable and mentioned in PRD) to use actual components instead of mocks/stubs for development environments, ensuring consistency with the goal of using real implementations.",
        "details": "Review DevConfig and replace any mock/stub bean definitions with configurations for the actual service and integration components. This ensures that the development environment closely mirrors the production and test environments using real dependencies.",
        "testStrategy": "Start the application in the development profile and verify that it initializes without errors and uses the configured real components.",
        "priority": "medium",
        "dependencies": [
          22,
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Refactor ReportControllerTest",
        "description": "Refactor ReportControllerTest to use the application context configured with real service and integration components, removing direct mock injection where possible.",
        "details": "Update ReportControllerTest to rely on the application context provided by the refactored TestConfig. Replace usages of injected mocks with interactions through the controller instance obtained from the context. Adjust test setup and assertions to work with the behavior of the real components.",
        "testStrategy": "Run the refactored ReportControllerTest suite. Ensure all tests pass and accurately reflect the behavior when using real dependencies. Verify test coverage is maintained or improved.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Refactor Other Controller Tests",
        "description": "Refactor other relevant controller tests to use the application context configured with real service and integration components, minimizing direct mock usage.",
        "details": "Apply the same refactoring approach used for ReportControllerTest (Task 26) to other controller test classes identified as using excessive mocks. Configure tests to load the application context with real beans and interact with controllers/services through the context.",
        "testStrategy": "Run the refactored controller test suites. Verify that tests pass and accurately test the controllers with real dependencies. Check for any unexpected failures or changes in behavior.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Refactor Service/Integration Tests",
        "description": "Review and refactor service and integration tests to use real dependencies where appropriate, shifting towards more integration-style testing and away from excessive unit tests with mocks.",
        "details": "Examine existing service and integration tests. For tests that heavily rely on mocking dependencies, evaluate if they can be converted to use the actual implemented dependencies (Tasks 22, 23) by loading a relevant application context slice. This improves test reliability by testing interactions between components.",
        "testStrategy": "Run the refactored service and integration test suites. Ensure tests pass and provide confidence in the integration of different components. Verify that the tests cover realistic interaction flows.",
        "priority": "medium",
        "dependencies": [
          22,
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Remove Temporary Code from Application",
        "description": "Scan the main application codebase (non-test code) for temporary return values, placeholder logic, or temporary object usage and replace them with calls to the newly implemented actual logic.",
        "details": "Based on the identification from Task 21, locate temporary code segments within the service, controller, or other application layers. Replace these temporary implementations with calls to the actual service logic (Task 22) or external integration code (Task 23). Remove any unused temporary classes or methods.",
        "testStrategy": "Perform manual code review to confirm temporary code has been removed. Run the application and perform basic functional tests to ensure the real logic is executed correctly.",
        "priority": "medium",
        "dependencies": [
          22,
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Conduct Comprehensive Testing with Real Components",
        "description": "Execute comprehensive test suites, including integration and end-to-end tests, in an environment configured with real components to ensure the system functions correctly and reliably without mocks/stubs.",
        "details": "Set up a test environment that uses the refactored configurations (Tasks 24, 25) and the newly implemented components (Tasks 22, 23). Run the full suite of automated tests, including unit tests (ensuring they still pass), integration tests, and end-to-end tests. Manually test critical user flows.",
        "testStrategy": "Monitor test execution results. Investigate and fix any failures. Compare results to expected behavior with real dependencies. Ensure test coverage is adequate and system reliability is confirmed.",
        "priority": "high",
        "dependencies": [
          24,
          25,
          26,
          27,
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Design and Implement Report Database Schema",
        "description": "Design and implement the database schema for storing report data, including fields for report content, status, user reference, file references, timestamps, etc.",
        "details": "Create SQL DDL scripts or use an ORM to define the `reports` table and related tables (e.g., `report_files`). Ensure fields accommodate required data like title, description, location (if applicable), status (e.g., DRAFT, SUBMITTED, PROCESSING, COMPLETED), user ID, creation/update timestamps, and foreign keys for files. Consider indexing for frequently queried fields like status or user ID.",
        "testStrategy": "Verify table and column creation in the database. Insert sample data manually to ensure schema integrity and data types are correct.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Report Entity/Model",
        "description": "Define the core data model/entity class(es) in the application code that map to the report database schema.",
        "details": "Create a `Report` entity class (e.g., in Java using JPA/Hibernate) with fields corresponding to the database columns defined in task 31. Include relationships to other entities like `User` or `ReportFile`. Ensure proper annotations for persistence.",
        "testStrategy": "Write unit tests for the entity class to ensure correct field mapping and basic object instantiation.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Create Report API and Logic",
        "description": "Implement the API endpoint and service logic for creating a new report, supporting both 'Draft' and 'Submitted' states.",
        "details": "Create a POST endpoint `/api/reports`. Implement the service method `createReport` in `ReportService.java`. This method should accept report data, validate required fields, set the initial status (defaulting to DRAFT or based on user input/action), associate the current user, and save the entity to the database using the repository. Address the TODO related to temporary DRAFT implementation.",
        "testStrategy": "Use integration tests to call the API endpoint with valid and invalid data. Verify that reports are created in the database with the correct status and associated user. Test both DRAFT and SUBMITTED creation flows.",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implement Read Report API and Logic",
        "description": "Implement API endpoints and service logic for retrieving single reports by ID and fetching lists of reports.",
        "details": "Create a GET endpoint `/api/reports/{id}` for fetching a single report. Implement `getReportById` in `ReportService.java`. Create a GET endpoint `/api/reports` for fetching a list. Implement `getAllReports` or `getReportsByUser` in `ReportService.java`. Consider basic filtering (e.g., by user, status) or pagination if needed, though the PRD only specifies '조회'. Ensure data is retrieved correctly from the database.",
        "testStrategy": "Write integration tests for both endpoints. Test fetching existing reports by ID and verifying the returned data. Test fetching lists of reports and verifying the number and content of results. Test edge cases like fetching a non-existent report (should return 404).",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Update Report API and Logic",
        "description": "Implement the API endpoint and service logic for updating an existing report.",
        "details": "Create a PUT or PATCH endpoint `/api/reports/{id}`. Implement `updateReport` in `ReportService.java`. This method should fetch the existing report (using logic from task 34), apply updates from the request body, validate changes (e.g., status transitions, required fields), and save the updated entity. Ensure only allowed fields can be updated based on the current status or user role.",
        "testStrategy": "Write integration tests to call the update endpoint. Test updating various fields on reports in different statuses (e.g., DRAFT, SUBMITTED). Verify that changes are persisted correctly in the database. Test updating non-existent reports or attempting invalid status transitions.",
        "priority": "medium",
        "dependencies": [
          32,
          34
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Delete Report API and Logic",
        "description": "Implement the API endpoint and service logic for deleting a report.",
        "details": "Create a DELETE endpoint `/api/reports/{id}`. Implement `deleteReport` in `ReportService.java`. This method should fetch the report (using logic from task 34) and remove it from the database. Consider soft deletion if required later, but start with hard deletion as per basic CRUD. Ensure associated files are also handled (e.g., marked for deletion or removed).",
        "testStrategy": "Write integration tests to call the delete endpoint. Test deleting existing reports. Verify that the report is removed from the database and subsequent GET requests for that ID return 404. Test deleting non-existent reports.",
        "priority": "medium",
        "dependencies": [
          32,
          34
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implement File Upload Functionality",
        "description": "Implement the functionality for uploading files (images) associated with a report.",
        "details": "Create an API endpoint (e.g., POST `/api/reports/{id}/files`) for file uploads. Implement service logic to handle multipart file requests, store files securely (e.g., on disk, S3), and create/associate `ReportFile` entities linked to the main `Report` entity (using logic from tasks 33 or 35). Handle file validation (type, size). Address the TODO related to file upload integration.",
        "testStrategy": "Write integration tests to upload files to existing reports. Verify that files are stored correctly and file metadata is saved in the database linked to the report. Test with different file types and sizes, including invalid ones. Test uploading to non-existent reports.",
        "priority": "high",
        "dependencies": [
          32,
          33,
          35
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Integrate with AI Analysis Service",
        "description": "Integrate with the AI analysis service to process uploaded files or report data.",
        "details": "Implement service logic to trigger an AI analysis request after a file is uploaded (task 37) or when a report reaches a certain status (e.g., SUBMITTED). This involves making an API call to the AI service, handling the response (including potential failures), and storing the analysis results (e.g., in the `Report` entity or a related table). Address the TODO related to AI analysis integration.",
        "testStrategy": "Write integration tests or mock the AI service to test the integration logic. Verify that the AI analysis request is triggered correctly and that the application handles successful responses and errors appropriately, storing results in the database.",
        "priority": "medium",
        "dependencies": [
          37
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Implement Report Status Management and Transitions",
        "description": "Refine and implement the full report status management logic and transitions.",
        "details": "Formalize the status states (DRAFT, SUBMITTED, PROCESSING, COMPLETED, etc.). Implement logic within the `updateReport` method (task 35) or dedicated endpoints/methods for administrators to change the report status. Ensure valid transitions are enforced (e.g., cannot go from COMPLETED back to DRAFT). Address the TODO related to temporary DRAFT handling.",
        "testStrategy": "Write unit and integration tests to verify status transition logic. Test valid transitions and attempt invalid transitions, ensuring the system prevents them and returns appropriate errors. Test status changes by different user roles if applicable.",
        "priority": "medium",
        "dependencies": [
          32,
          33,
          35
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Implement Authentication, Authorization, and Comprehensive Error Handling",
        "description": "Implement user authentication and authorization checks for all report operations and handle various exception/error scenarios.",
        "details": "Implement security checks (e.g., using Spring Security) to ensure users are authenticated and have the necessary permissions (e.g., only report creator can edit DRAFT, only admin/handler can change status to PROCESSING/COMPLETED). Implement centralized exception handling (e.g., using `@ControllerAdvice`) to catch specific exceptions (e.g., `ResourceNotFoundException`, `AccessDeniedException`, `ValidationException`, file upload errors, AI errors) and return appropriate HTTP status codes and error messages as per the PRD's error handling requirements.",
        "testStrategy": "Write integration tests covering all API endpoints (CRUD, file upload, status change). Test requests from unauthenticated users, users without necessary permissions, and users with correct permissions. Test scenarios triggering specific errors (e.g., missing required fields, invalid ID, file upload failure) and verify that correct error responses are returned.",
        "priority": "high",
        "dependencies": [
          33,
          34,
          35,
          36,
          37,
          38,
          39
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Project Setup and Basic Service Structure",
        "description": "Set up the project repository, basic structure, and include necessary dependencies for implementing the statistics, priority, and ticket services as identified in the TODO section.",
        "details": "Initialize a new project repository. Define the basic package structure for StatisticsService, PriorityEscalationService, and KafkaTicketService. Include core dependencies for data processing, potentially a database connector (if needed for statistics storage), and Kafka client libraries.",
        "testStrategy": "Verify project setup, dependency inclusion, and basic service class structure compilation.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Implement Statistics Aggregation Logic",
        "description": "Implement the core logic for aggregating statistical data from various sources like reports and notifications.",
        "details": "Develop the data aggregation module within StatisticsService. This involves defining data models for statistics, implementing logic to process incoming data events (from reports, notifications, etc.), and aggregating metrics. Consider using an in-memory store or a database for temporary or persistent storage during aggregation. Focus on handling potential data volume.",
        "testStrategy": "Write unit tests for aggregation functions with various data inputs. Verify that metrics are correctly calculated and stored.",
        "priority": "medium",
        "dependencies": [
          41
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Implement Statistics Lookup Logic",
        "description": "Implement the core logic for querying and retrieving aggregated statistical data.",
        "details": "Develop the data lookup module within StatisticsService. This involves implementing functions to query the aggregated data based on various criteria (e.g., time range, data type). Ensure efficient retrieval mechanisms, considering the potential for large data volumes. Define the output format for statistical data.",
        "testStrategy": "Write unit tests for lookup functions with different query parameters. Verify that the correct aggregated data is returned in the expected format.",
        "priority": "medium",
        "dependencies": [
          41,
          42
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement Automatic Priority Adjustment Logic",
        "description": "Implement the automatic priority adjustment logic based on incoming data characteristics.",
        "details": "Develop the core logic within PriorityEscalationService. This involves defining rules or algorithms for determining the priority of an item (e.g., a ticket, a notification) based on its attributes (urgency, type, source, etc.). The logic should automatically adjust priority levels as needed.",
        "testStrategy": "Write unit tests for the priority adjustment logic with various input data scenarios. Verify that the correct priority level is assigned or adjusted according to the defined rules.",
        "priority": "medium",
        "dependencies": [
          41
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Implement Ticket Issuance Logic",
        "description": "Implement the logic for issuing new tickets, potentially triggered by data events or priority adjustments.",
        "details": "Develop the ticket issuance module within KafkaTicketService. This involves creating a new ticket object based on input data, assigning initial attributes (like priority determined by Task 44), and preparing it for processing. This module will likely interact with Kafka to publish the new ticket event.",
        "testStrategy": "Write unit tests for the ticket issuance function. Verify that a valid ticket object is created with correct initial attributes based on input data.",
        "priority": "medium",
        "dependencies": [
          41
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Implement Ticket Processing Logic",
        "description": "Implement the logic for processing issued tickets, potentially involving status updates, assignments, or further actions.",
        "details": "Develop the ticket processing module within KafkaTicketService. This involves consuming ticket events from Kafka (implemented in Task 48), updating ticket status, potentially assigning the ticket, or triggering subsequent actions based on the ticket type or priority. This module represents the 'handling' part of the ticket lifecycle.",
        "testStrategy": "Write unit tests for the ticket processing function. Verify that ticket status is updated correctly and subsequent actions are triggered based on ticket data.",
        "priority": "medium",
        "dependencies": [
          41,
          45
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement Statistics Data Lookup API",
        "description": "Implement API endpoints to expose the statistical data lookup functionality.",
        "details": "Design and implement RESTful API endpoints (e.g., /api/statistics) that accept query parameters (like date range, filters) and utilize the StatisticsService lookup logic (Task 43) to return aggregated data. Ensure proper request validation and response formatting (e.g., JSON).",
        "testStrategy": "Use integration tests to call the API endpoints with various valid and invalid parameters. Verify that the correct data is returned and error responses are handled appropriately.",
        "priority": "high",
        "dependencies": [
          43
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Integrate Kafka for Ticket Events",
        "description": "Integrate the Kafka client with the KafkaTicketService for publishing and consuming ticket events.",
        "details": "Configure Kafka producers and consumers within the KafkaTicketService. Implement the logic to publish new ticket events to a Kafka topic (using Task 45 logic) and consume ticket processing events from another topic (using Task 46 logic). Handle serialization/deserialization of ticket data.",
        "testStrategy": "Set up a test Kafka instance. Write integration tests to verify that ticket events published by the service are received by a consumer and vice versa.",
        "priority": "high",
        "dependencies": [
          45,
          46
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implement Main Data Processing Flow",
        "description": "Implement the main data processing flow that orchestrates the calls to statistics aggregation, priority adjustment, and ticket issuance/processing based on incoming data events.",
        "details": "Create a central processing module or service that listens for data occurrence events (reports, notifications). Upon receiving an event, trigger the statistics aggregation (Task 42), priority adjustment (Task 44), and potentially ticket issuance (Task 45 via Kafka Task 48). This module connects the individual service components.",
        "testStrategy": "Implement end-to-end integration tests simulating data occurrence events. Verify that statistics are aggregated, priority is adjusted, and tickets are correctly issued via Kafka.",
        "priority": "high",
        "dependencies": [
          42,
          44,
          48
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement Comprehensive Error Handling",
        "description": "Implement comprehensive error handling mechanisms for data aggregation errors, Kafka failures, and permission issues within the processing flow and APIs.",
        "details": "Add error handling blocks (try-catch, specific exception handling) in the statistics aggregation, priority adjustment, ticket service, Kafka integration, and API layers. Implement logging for errors. Define specific error responses for the API (Task 47). Handle Kafka connection errors and message processing failures (e.g., dead-letter queues). Implement permission checks where necessary.",
        "testStrategy": "Introduce simulated errors (e.g., invalid data, Kafka disconnects, permission denied) during testing of Task 49 flow and Task 47 API. Verify that errors are caught, logged, and handled gracefully without crashing the application.",
        "priority": "high",
        "dependencies": [
          49
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Performance Optimization for Large Data and Real-time",
        "description": "Optimize the implemented services and flow to handle large data volumes and meet real-time processing requirements.",
        "details": "Review the implementation of Tasks 42-49 for performance bottlenecks. Consider using efficient data structures, asynchronous processing, batching for Kafka, database indexing for statistics lookup, and potentially caching. Profile the application under load to identify areas for optimization.",
        "testStrategy": "Conduct load testing on the system with simulated large data volumes and high throughput. Monitor resource usage (CPU, memory, network) and processing latency. Verify that the system remains stable and meets performance criteria.",
        "priority": "medium",
        "dependencies": [
          49
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Refactor Core Authentication/Authorization Components",
        "description": "Analyze and refactor existing code related to temporary tokens and states in components like AuthResponse, JwtTokenProvider, and OAuth2AuthenticationSuccessHandler to prepare for implementing the final logic.",
        "details": "Review the current implementation in AuthResponse, JwtTokenProvider, and OAuth2AuthenticationSuccessHandler. Identify temporary logic, mock objects, or hardcoded values related to temporary tokens and states. Refactor these components to create clear interfaces or structures that can accommodate the new temporary and final token/state management logic without breaking existing (temporary) functionality initially. Document the identified temporary parts.",
        "testStrategy": "Code review of refactored components. Ensure existing temporary flows (if any are functional) still compile and run. Unit tests for any new helper classes or interfaces introduced during refactoring.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Implement Temporary Token Generation",
        "description": "Implement the logic to generate a temporary token (tempToken) upon successful social login, as required by the flow.",
        "details": "Create a dedicated service or method for generating tempTokens. These tokens should be short-lived and uniquely identifiable, potentially linked to a temporary user profile or session data. Use a secure method for generation (e.g., UUID, short-lived JWT with minimal claims). Store the generated tempToken along with an expiration timestamp and associated temporary user data in a temporary storage (e.g., cache like Redis, or a dedicated temporary database table).",
        "testStrategy": "Unit tests for the token generation logic: verify token format, uniqueness, association with user data, and presence of expiration timestamp. Test generation under load.",
        "priority": "medium",
        "dependencies": [
          52
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Implement Temporary Token Validation",
        "description": "Implement the logic to validate a provided temporary token (tempToken).",
        "details": "Create a service or method to receive a tempToken, look it up in the temporary storage, and verify its existence and validity (i.e., not expired). This validation should retrieve the associated temporary user data.",
        "testStrategy": "Unit tests for the validation logic: test with valid tokens, invalid tokens, non-existent tokens, and tokens that are about to expire. Verify correct user data is retrieved upon successful validation.",
        "priority": "medium",
        "dependencies": [
          52
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Implement Temporary Token Expiration Handling",
        "description": "Implement the mechanism to handle temporary token expiration, including invalidating or removing expired tokens.",
        "details": "Add logic to the validation process (Task 54) to check the expiration timestamp and reject expired tokens. Implement a background job or scheduled task to periodically clean up expired tempTokens from the temporary storage to prevent accumulation and potential security risks. Ensure expired tokens cannot be used for any subsequent operations.",
        "testStrategy": "Unit tests for expiration check during validation. Integration tests to verify that tokens become invalid after their expiration time. Test the cleanup job by generating tokens, waiting for expiration, and verifying their removal or invalidation.",
        "priority": "medium",
        "dependencies": [
          54
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Implement Temporary State Management Logic",
        "description": "Implement the core logic for managing temporary states (e.g., DRAFT, SOCIAL_LOGIN_PENDING_INFO) associated with user profiles or entities.",
        "details": "Define an enumeration or set of possible temporary states (e.g., DRAFT for temporary saves, SOCIAL_LOGIN_PENDING_INFO for users who logged in via social provider but need to complete profile). Add a state field to the relevant user or entity data structure (potentially temporary). Implement methods to set and retrieve the current state.",
        "testStrategy": "Unit tests for setting and retrieving different temporary states. Ensure states are correctly associated with the respective entity/user data.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Implement State Transition Logic (Temporary to Actual)",
        "description": "Implement the logic to transition from a temporary state to a final, actual state based on specific user actions or conditions.",
        "details": "Create a service or method that takes an entity/user and a target state. Implement the rules for valid state transitions (e.g., SOCIAL_LOGIN_PENDING_INFO can transition to ACTIVE after profile completion; DRAFT can transition to PUBLISHED after submission). This logic should verify the current state before allowing a transition. This might involve checking if required information is present (e.g., for social login users).",
        "testStrategy": "Unit tests for state transition logic: test valid transitions from various temporary states. Test invalid transition attempts. Test conditions required for transition (e.g., profile data completeness).",
        "priority": "medium",
        "dependencies": [
          56
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Implement Actual User Token Issuance",
        "description": "Implement the logic for issuing the final, actual user token (e.g., long-lived JWT) after temporary token validation and successful state transition (e.g., after additional info is provided).",
        "details": "Refine or implement the standard token issuance logic within JwtTokenProvider or a dedicated service. This logic should be triggered after a user successfully completes the temporary phase (e.g., provides additional info using a valid tempToken, leading to a state transition). The actual token should contain necessary claims for the fully registered/verified user.",
        "testStrategy": "Unit tests for actual token generation: verify token format, claims, and signature. Integration tests to ensure the actual token is issued only after successful temporary token validation and state transition.",
        "priority": "medium",
        "dependencies": [
          52,
          54,
          57
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Integrate Temporary Token Flow into Social Login",
        "description": "Integrate the temporary token generation, validation, and expiration handling into the social login and subsequent user flow.",
        "details": "Modify OAuth2AuthenticationSuccessHandler to issue a tempToken (Task 53) instead of a final token upon initial social login success. Create or modify endpoints/controllers that require a valid tempToken for actions like submitting additional profile information. Implement the validation check (Task 54) using the tempToken for these endpoints. Ensure expired tempTokens (Task 55) are rejected.",
        "testStrategy": "Integration tests covering the social login flow: successful login -> tempToken issued. Accessing tempToken-protected endpoints with valid/invalid/expired tempTokens. Verify correct responses (success/failure).",
        "priority": "medium",
        "dependencies": [
          53,
          54,
          55
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Integrate Temporary State Management into User Flows",
        "description": "Integrate the temporary state management and transition logic into the relevant user flows, such as profile completion after social login or temporary save features.",
        "details": "In the social login flow (Task 59), set the initial temporary state (Task 56) for the user. When the user submits additional information (using the tempToken), trigger the state transition logic (Task 57). Upon successful transition to a final state, issue the actual user token (Task 58). Apply similar state management for other features requiring temporary states (e.g., draft posts).",
        "testStrategy": "Integration tests covering the full user journey: Social login -> initial temporary state set -> submit info -> state transitions to final -> actual token issued. Test temporary save/draft flows if applicable, verifying state changes.",
        "priority": "medium",
        "dependencies": [
          56,
          57,
          58,
          59
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 61,
        "title": "Replace Mocks and Implement Comprehensive Exception Handling",
        "description": "Identify and replace any remaining temporary return values or mock objects, and implement comprehensive exception handling for temporary token and state-related errors.",
        "details": "Review the codebase, particularly components mentioned in the PRD (AuthResponse, handlers) and newly modified ones, to ensure all temporary return values, mock objects, or placeholder logic have been replaced with the actual implementations (Tasks 58, 59, 60). Implement specific exception types and handlers for errors like tempToken expiration, invalid tempToken, invalid state transitions, missing required information during state transition, etc. Ensure appropriate error responses are returned to the client.",
        "testStrategy": "System tests covering all identified error scenarios (expired token usage, invalid state transition attempts, etc.). Verify correct error codes and messages are returned. Final code review to confirm removal of all temporary/mock implementations mentioned in the PRD's TODO section.",
        "priority": "medium",
        "dependencies": [
          58,
          59,
          60
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-12T14:09:06.422Z",
      "updated": "2025-07-12T14:46:19.479Z",
      "description": "Tasks for register-login-req context"
    }
  }
}